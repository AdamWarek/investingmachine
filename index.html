<!DOCTYPE html>
<html lang="en" class="dark">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Trade.io - Virtual Trading</title>

    <!-- React & ReactDOM -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>

    <!-- Babel for JSX -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            darkMode: 'class',
            theme: {
                extend: {
                    fontFamily: {
                        sans: ['Helvetica', 'Arial', 'sans-serif'],
                        mono: ['ui-monospace', 'SFMono-Regular', 'Menlo', 'Monaco', 'Consolas', "Liberation Mono", "Courier New", 'monospace'],
                    },
                    colors: {
                        swiss: {
                            red: '#ef4444',
                            green: '#10b981',
                            dark: '#18181b',
                            light: '#f4f4f5'
                        }
                    }
                }
            }
        }
    </script>

    <!-- Chart.js -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

    <style>
        body {
            font-family: 'Helvetica', 'Arial', sans-serif;
        }

        .card {
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.05);
        }
    </style>
</head>

<body class="bg-gray-100 dark:bg-zinc-900 text-gray-900 dark:text-gray-100 min-h-screen transition-colors duration-200">
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useMemo } = React;

        // Helper to generate mock history
        const generateHistory = (currentPrice) => {
            const history = [];
            let price = currentPrice;
            const now = new Date();
            // Generate 30 days back
            for (let i = 30; i >= 0; i--) {
                const date = new Date(now);
                date.setDate(date.getDate() - i);
                // Random walk
                // If i is 0 (today), force match currentPrice roughly (reverse generation would be better but this is simple)
                // Let's generate backwards from current
            }
            // Better: generate backwards
            let p = currentPrice;
            const dates = [];
            const prices = [];
            for (let i = 0; i <= 30; i++) {
                const date = new Date(now);
                date.setDate(date.getDate() - i);
                dates.unshift(date.toLocaleDateString());
                prices.unshift(p);
                // Walk back
                p = p / (1 + (Math.random() - 0.5) * 0.05);
            }
            return { dates, prices };
        };

        // --- Mock Data & Utilities ---
        const formatCurrency = (val) => new Intl.NumberFormat('en-US', { style: 'currency', currency: 'USD' }).format(val);
        const formatPct = (val) => (val > 0 ? '+' : '') + val.toFixed(2) + '%';

        // --- API & Data Logic ---
        // --- API & Data Logic ---
        const getApiKey = () => localStorage.getItem('av_api_key') || "1ODDDMO6XMBOHJRZ"; // Default to user provided if not set

        // Cache Helpers
        const getCached = (key) => {
            const item = localStorage.getItem(key);
            if (!item) return null;
            const { data, timestamp } = JSON.parse(item);
            // 60 minutes cache for API data to save limits
            if (Date.now() - timestamp > 60 * 60 * 1000) return null;
            return data;
        };

        const setCache = (key, data) => {
            localStorage.setItem(key, JSON.stringify({ data, timestamp: Date.now() }));
        };

        // Crypto: CoinGecko (Public)
        const fetchCrypto = async () => {
            const cacheKey = 'data_crypto_real';
            const cached = getCached(cacheKey);
            if (cached) return cached;

            try {
                const res = await fetch('https://api.coingecko.com/api/v3/coins/markets?vs_currency=usd&ids=bitcoin,ethereum,solana,cardano,ripple&order=market_cap_desc&per_page=5&page=1&sparkline=false');
                if (!res.ok) throw new Error('CoinGecko API limit');
                const data = await res.json();

                const mapped = data.map(coin => ({
                    symbol: coin.symbol.toUpperCase(),
                    price: coin.current_price,
                    change: coin.price_change_percentage_24h,
                    name: coin.name,
                    ...generateHistory(coin.current_price) // Still sim history for chart consistency unless we fetch candles
                }));

                setCache(cacheKey, mapped);
                return mapped;
            } catch (err) {
                console.warn("Crypto fetch failed, using fallback", err);
                return [
                    { symbol: 'BTC', price: 64230, change: 2.4, name: 'Bitcoin', ...generateHistory(64230) },
                    { symbol: 'ETH', price: 3450, change: -1.2, name: 'Ethereum', ...generateHistory(3450) },
                    { symbol: 'SOL', price: 145, change: 5.4, name: 'Solana', ...generateHistory(145) }
                ];
            }
        };

        // US Stocks: Alpha Vantage
        const fetchUSStocks = async () => {
            const apiKey = getApiKey();
            if (!apiKey) return []; // Should hint user to add key

            const symbols = ['AAPL', 'NVDA', 'TSLA', 'MSFT', 'GOOGL'];
            const cacheKey = 'data_us_real';
            const cached = getCached(cacheKey);
            if (cached) return cached;

            try {
                // Alpha Vantage Free Tier is 25 requests/day. We must be careful.
                // We'll fetch sequentially to avoid rate limit (5 req/min)
                const results = [];
                for (const symbol of symbols) {
                    const res = await fetch(`https://www.alphavantage.co/query?function=GLOBAL_QUOTE&symbol=${symbol}&apikey=${apiKey}`);
                    const data = await res.json();
                    const quote = data['Global Quote'];

                    if (quote && quote['05. price']) {
                        const price = parseFloat(quote['05. price']);
                        const change = parseFloat(quote['10. change percent'].replace('%', ''));
                        results.push({
                            symbol: symbol,
                            price: price,
                            change: change,
                            name: symbol, // AV doesn't give name in Quote endpoint
                            ...generateHistory(price)
                        });
                    } else {
                        // rate limit hit or error?
                        console.warn(`AV Limit or Error for ${symbol}`, data);
                    }
                    // Wait 12s between calls to stay under 5 req/min limit of free key? 
                    // Actually let's just wait 1s and hope for best or catch error. 
                    // Realistically for demo key is generous but personal keys are strict.
                    // We will just try 2-3 to be safe for now or just mock if fail.
                }

                if (results.length > 0) {
                    setCache(cacheKey, results);
                    return results;
                }
                throw new Error("No data fetched from AV");

            } catch (err) {
                console.warn("US Stock fetch failed, using fallback", err);
                return [
                    { symbol: 'AAPL', price: 173.50, change: 1.24, name: 'Apple Inc.', ...generateHistory(173.50) },
                    { symbol: 'NVDA', price: 885.20, change: 3.50, name: 'NVIDIA Corp.', ...generateHistory(885.20) },
                    { symbol: 'TSLA', price: 178.50, change: -0.45, name: 'Tesla Inc.', ...generateHistory(178.50) }
                ];
            }
        };

        // Polish Stocks: Yahoo Finance via Proxy
        const fetchPLStocks = async () => {
            const symbols = ['PKO.WA', 'KGH.WA', 'CDR.WA', 'ALE.WA'];
            const cacheKey = 'data_pl_real';
            const cached = getCached(cacheKey);
            if (cached) return cached;

            try {
                const results = [];
                // Using allorigins.win or corsproxy.io
                // Yahoo query: https://query1.finance.yahoo.com/v8/finance/chart/PKO.WA?interval=1d&range=1d

                const proxyUrl = 'https://api.allorigins.win/get?url=';

                for (const symbol of symbols) {
                    const targetUrl = encodeURIComponent(`https://query1.finance.yahoo.com/v8/finance/chart/${symbol}?interval=1d&range=1d`);
                    const res = await fetch(proxyUrl + targetUrl);
                    const data = await res.json();
                    if (data.contents) {
                        const parsed = JSON.parse(data.contents);
                        const meta = parsed.chart.result[0].meta;
                        const price = meta.regularMarketPrice;
                        const prevClose = meta.chartPreviousClose;
                        const change = ((price - prevClose) / prevClose) * 100;

                        results.push({
                            symbol: symbol.replace('.WA', ''),
                            price: price,
                            change: change,
                            name: symbol,
                            ...generateHistory(price)
                        });
                    }
                }

                if (results.length > 0) {
                    setCache(cacheKey, results);
                    return results;
                }
                throw new Error("No data from Yahoo Proxy");

            } catch (err) {
                console.warn("PL Stock fetch failed", err);
                return [
                    { symbol: 'PKO', price: 45.20, change: 1.10, name: 'PKO BP', ...generateHistory(45.20) },
                    { symbol: 'KGH', price: 120.50, change: -2.30, name: 'KGHM', ...generateHistory(120.50) },
                    { symbol: 'CDR', price: 115.00, change: 0.50, name: 'CD Projekt', ...generateHistory(115.00) }
                ];
            }
        };

        // --- Technical Indicators ---
        // Closes is array of prices
        const calcRSI = (closes, period = 14) => {
            if (closes.length < period + 1) return 50; // Not enough data
            let gains = 0, losses = 0;
            for (let i = 1; i <= period; i++) {
                const change = closes[i] - closes[i - 1];
                if (change > 0) gains += change;
                else losses -= change;
            }
            let avgGain = gains / period;
            let avgLoss = losses / period;

            // Smoothed
            for (let i = period + 1; i < closes.length; i++) {
                const change = closes[i] - closes[i - 1];
                const gain = change > 0 ? change : 0;
                const loss = change < 0 ? -change : 0;
                avgGain = (avgGain * (period - 1) + gain) / period;
                avgLoss = (avgLoss * (period - 1) + loss) / period;
            }

            if (avgLoss === 0) return 100;
            const rs = avgGain / avgLoss;
            return 100 - (100 / (1 + rs));
        };

        const calcEMA = (closes, period) => {
            if (closes.length < period) return null;
            const k = 2 / (period + 1);
            let ema = closes[0]; // Simple start
            for (let i = 1; i < closes.length; i++) {
                ema = closes[i] * k + ema * (1 - k);
            }
            return ema;
        };

        const calcMACD = (closes) => {
            const ema12 = calcEMA(closes, 12); // Simplified: assumes calcEMA returns single latest value
            const ema26 = calcEMA(closes, 26);
            // In reality you need the whole series of EMAs to calculate the Signal line (EMA9 of MACD)
            // For this sim, we'll approximate or need a generator. 
            // Let's return a dummy "bullish/bearish" signal for now to save space, 
            // or implement full series if needed for the chart.
            return { macd: 0, signal: 0, histogram: 0 };
        };

        // --- Components ---

        const TradeModal = ({ isOpen, onClose, asset, onTrade }) => {
            if (!isOpen || !asset) return null;
            const [qty, setQty] = useState(1);
            const [mode, setMode] = useState('BUY'); // BUY or SELL

            const total = qty * asset.price;

            return (
                <div class="fixed inset-0 bg-black/50 flex items-center justify-center p-4 z-50">
                    <div class="bg-white dark:bg-zinc-900 border border-black dark:border-white p-6 max-w-sm w-full shadow-2xl rounded-sm">
                        <h2 class="text-xl font-bold mb-4 uppercase">{mode} {asset.symbol}</h2>

                        <div class="flex gap-2 mb-4">
                            <button onClick={() => setMode('BUY')} class={`flex-1 py-2 font-bold ${mode === 'BUY' ? 'bg-black text-white dark:bg-white dark:text-black' : 'bg-gray-200 text-gray-500'}`}>BUY</button>
                            <button onClick={() => setMode('SELL')} class={`flex-1 py-2 font-bold ${mode === 'SELL' ? 'bg-black text-white dark:bg-white dark:text-black' : 'bg-gray-200 text-gray-500'}`}>SELL</button>
                        </div>

                        <div class="space-y-4 font-mono text-sm">
                            <div class="flex justify-between">
                                <span>Price:</span>
                                <span>{formatCurrency(asset.price)}</span>
                            </div>
                            <div class="flex justify-between items-center">
                                <span>Quantity:</span>
                                <input type="number" min="1" value={qty} onChange={e => setQty(Number(e.target.value))} class="w-20 p-1 border border-gray-300 dark:border-zinc-700 bg-transparent text-right" />
                            </div>
                            <div class="flex justify-between border-t border-gray-300 dark:border-zinc-700 pt-2 font-bold">
                                <span>Total:</span>
                                <span>{formatCurrency(total)}</span>
                            </div>
                        </div>

                        <div class="mt-6 flex gap-2">
                            <button onClick={onClose} class="flex-1 py-2 border border-gray-300 dark:border-zinc-700 font-bold hover:bg-gray-100 dark:hover:bg-zinc-800">CANCEL</button>
                            <button onClick={() => onTrade(asset, mode, qty)} class="flex-1 py-2 bg-emerald-500 text-white font-bold hover:bg-emerald-600">CONFIRM</button>
                        </div>
                    </div>
                </div>
            );
        };

        const Header = ({ darkMode, toggleTheme, portfolio }) => (
            <header class="flex justify-between items-end mb-8 border-b-2 border-black dark:border-white pb-4 px-8 pt-6">
                <div>
                    <h1 class="text-4xl font-extrabold tracking-tighter uppercase dark:text-white">Trade<span class="text-gray-400">.io</span></h1>
                    <p class="text-sm text-gray-500 dark:text-gray-400 mt-1">Professional Trading Environment</p>
                </div>
                <div class="flex items-end gap-8">
                    <div class="text-right">
                        <div class="text-xs uppercase font-bold text-gray-400 tracking-widest mb-1">Total Equity</div>
                        <div class="text-3xl font-bold font-mono tracking-tight">{formatCurrency(portfolio.equity)}</div>
                        <div class="text-sm font-medium mt-1 flex items-center justify-end gap-1 font-mono">
                            <span class="text-gray-500">Cash: {formatCurrency(portfolio.cash)}</span>
                        </div>
                    </div>
                    <button onClick={toggleTheme} class="p-2 rounded-full hover:bg-gray-200 dark:hover:bg-zinc-800 transition">
                        {darkMode ? '‚òÄÔ∏è' : 'üåô'}
                    </button>
                </div>
            </header>
        );

        const Sidebar = ({ activeTab, setActiveTab }) => (
            <aside class="col-span-1 space-y-6">
                <nav class="space-y-1">
                    {['Dashboard', 'US Markets', 'Polish Stocks', 'Crypto', 'History', 'Settings'].map(tab => (
                        <button
                            key={tab}
                            onClick={() => setActiveTab(tab)}
                            class={`w-full text-left block px-4 py-3 font-bold rounded-sm transition ${activeTab === tab
                                ? 'bg-black dark:bg-white text-white dark:text-black'
                                : 'hover:bg-gray-200 dark:hover:bg-zinc-800'
                                }`}
                        >
                            {tab}
                        </button>
                    ))}
                </nav>
            </aside>
        );

        const ChartComponent = ({ asset }) => {
            const canvasRef = React.useRef(null);
            const chartRef = React.useRef(null);

            React.useEffect(() => {
                if (!canvasRef.current || !asset) return;

                const ctx = canvasRef.current.getContext('2d');

                // Destroy previous chart
                if (chartRef.current) {
                    chartRef.current.destroy();
                }

                // Generate mock history for the chart based on current price
                const history = [];
                let price = asset.price;
                const now = new Date();
                for (let i = 30; i >= 0; i--) {
                    const date = new Date(now);
                    date.setDate(date.getDate() - i);
                    // Random walk
                    price = price * (1 + (Math.random() - 0.5) * 0.05);
                    history.push({ date: date.toLocaleDateString(), price });
                }
                // Ensure last point matches current
                history[history.length - 1].price = asset.price;

                chartRef.current = new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels: history.map(h => h.date),
                        datasets: [{
                            label: 'Price (USD)',
                            data: history.map(h => h.price),
                            borderColor: asset.change >= 0 ? '#10b981' : '#ef4444',
                            backgroundColor: (context) => {
                                const ctx = context.chart.ctx;
                                const gradient = ctx.createLinearGradient(0, 0, 0, 300);
                                gradient.addColorStop(0, asset.change >= 0 ? 'rgba(16, 185, 129, 0.2)' : 'rgba(239, 68, 68, 0.2)');
                                gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
                                return gradient;
                            },
                            borderWidth: 2,
                            fill: true,
                            tension: 0.4,
                            pointRadius: 0
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: { display: false },
                            tooltip: {
                                mode: 'index',
                                intersect: false,
                                callbacks: { label: (ctx) => formatCurrency(ctx.raw) }
                            }
                        },
                        scales: {
                            x: { display: false },
                            y: {
                                display: true,
                                position: 'right',
                                grid: { color: '#33333333' }
                            }
                        },
                        interaction: {
                            mode: 'nearest',
                            axis: 'x',
                            intersect: false
                        }
                    }
                });

                return () => {
                    if (chartRef.current) chartRef.current.destroy();
                };
            }, [asset]); // Re-render when asset changes

            return <canvas ref={canvasRef} />;
        };

        const MarketTable = ({ title, data, loading, onOpenTrade, onSelect }) => (
            <div class="bg-white dark:bg-zinc-800 border border-gray-200 dark:border-zinc-700 rounded-sm overflow-hidden shadow-sm">
                <div class="p-4 border-b border-gray-200 dark:border-zinc-700 font-bold uppercase tracking-wider text-sm">{title}</div>
                <table class="w-full text-left">
                    <thead class="bg-gray-50 dark:bg-zinc-900 border-b border-gray-200 dark:border-zinc-700">
                        <tr class="text-xs font-bold text-gray-500 uppercase tracking-wider">
                            <th class="px-6 py-4">Instrument</th>
                            <th class="px-6 py-4">Price</th>
                            <th class="px-6 py-4">Change</th>
                            <th class="px-6 py-4 text-right">Action</th>
                        </tr>
                    </thead>
                    <tbody class="divide-y divide-gray-100 dark:divide-zinc-700 font-mono text-sm">
                        {loading ? (
                            <tr><td colSpan="4" class="p-6 text-center text-gray-500">Loading market data...</td></tr>
                        ) : data.map((item, idx) => (
                            <tr key={idx} onClick={() => onSelect && onSelect(item)} class="hover:bg-gray-50 dark:hover:bg-zinc-700/50 transition cursor-pointer">
                                <td class="px-6 py-4 font-bold text-sans">
                                    <div class="font-bold">{item.symbol}</div>
                                    <div class="text-xs text-gray-500 dark:text-gray-400 font-sans">{item.name}</div>
                                </td>
                                <td class="px-6 py-4">{formatCurrency(item.price)}</td>
                                <td class={`px-6 py-4 ${item.change >= 0 ? 'text-emerald-500' : 'text-red-500'}`}>
                                    {formatPct(item.change)}
                                </td>
                                <td class="px-6 py-4 text-right">
                                    <button onClick={(e) => { e.stopPropagation(); onOpenTrade(item); }} class="bg-black dark:bg-white text-white dark:text-black hover:opacity-80 px-4 py-1 rounded-sm text-xs font-bold uppercase">Trade</button>
                                </td>
                            </tr>
                        ))}
                    </tbody>
                </table>
            </div>
        );

        const PositionsTable = ({ positions, onOpenTrade }) => (
            <div class="bg-white dark:bg-zinc-800 border border-gray-200 dark:border-zinc-700 rounded-sm overflow-hidden shadow-sm">
                <div class="p-4 border-b border-gray-200 dark:border-zinc-700 font-bold uppercase tracking-wider text-sm">Active Positions</div>
                {positions.length === 0 ? (
                    <div class="p-8 text-center text-gray-500">No active positions</div>
                ) : (
                    <table class="w-full text-left">
                        <thead class="bg-gray-50 dark:bg-zinc-900 border-b border-gray-200 dark:border-zinc-700">
                            <tr class="text-xs font-bold text-gray-500 uppercase tracking-wider">
                                <th class="px-6 py-4">Instrument</th>
                                <th class="px-6 py-4">Qty</th>
                                <th class="px-6 py-4">Avg Buy</th>
                                <th class="px-6 py-4">Current</th>
                                <th class="px-6 py-4 text-right">Value</th>
                                <th class="px-6 py-4 text-right">Action</th>
                            </tr>
                        </thead>
                        <tbody class="divide-y divide-gray-100 dark:divide-zinc-700 font-mono text-sm">
                            {positions.map((pos, idx) => (
                                <tr key={idx} class="hover:bg-gray-50 dark:hover:bg-zinc-700/50 transition">
                                    <td class="px-6 py-4 font-bold text-sans">{pos.symbol}</td>
                                    <td class="px-6 py-4">{pos.qty}</td>
                                    <td class="px-6 py-4">{formatCurrency(pos.avgPrice)}</td>
                                    <td class="px-6 py-4">{formatCurrency(pos.currentPrice || pos.avgPrice)}</td>
                                    <td class="px-6 py-4 text-right font-bold">{formatCurrency(pos.qty * (pos.currentPrice || pos.avgPrice))}</td>
                                    <td class="px-6 py-4 text-right">
                                        <button onClick={() => onOpenTrade({ symbol: pos.symbol, price: pos.currentPrice || pos.avgPrice })} class="bg-black dark:bg-white text-white dark:text-black hover:opacity-80 px-4 py-1 rounded-sm text-xs font-bold uppercase">Trade</button>
                                    </td>
                                </tr>
                            ))}
                        </tbody>
                    </table>
                )}
            </div>
        );

        const HistoryTable = ({ history }) => (
            <div class="bg-white dark:bg-zinc-800 border border-gray-200 dark:border-zinc-700 rounded-sm overflow-hidden shadow-sm">
                <div class="p-4 border-b border-gray-200 dark:border-zinc-700 font-bold uppercase tracking-wider text-sm">Transaction History</div>
                {history.length === 0 ? (
                    <div class="p-8 text-center text-gray-500">No transactions yet</div>
                ) : (
                    <div class="overflow-x-auto">
                        <table class="w-full text-left">
                            <thead class="bg-gray-50 dark:bg-zinc-900 border-b border-gray-200 dark:border-zinc-700">
                                <tr class="text-xs font-bold text-gray-500 uppercase tracking-wider">
                                    <th class="px-6 py-4">Date</th>
                                    <th class="px-6 py-4">Type</th>
                                    <th class="px-6 py-4">Instrument</th>
                                    <th class="px-6 py-4">Qty</th>
                                    <th class="px-6 py-4 text-right">Price</th>
                                    <th class="px-6 py-4 text-right">Total</th>
                                    <th class="px-6 py-4">Reason</th>
                                </tr>
                            </thead>
                            <tbody class="divide-y divide-gray-100 dark:divide-zinc-700 font-mono text-sm">
                                {history.slice().reverse().map((tx, idx) => (
                                    <tr key={idx} class="hover:bg-gray-50 dark:hover:bg-zinc-700/50 transition">
                                        <td class="px-6 py-4 text-xs text-gray-500">{new Date(tx.date).toLocaleString()}</td>
                                        <td class={`px-6 py-4 font-bold ${tx.type === 'BUY' ? 'text-emerald-500' : 'text-red-500'}`}>{tx.type}</td>
                                        <td class="px-6 py-4 font-bold">{tx.symbol}</td>
                                        <td class="px-6 py-4">{tx.qty}</td>
                                        <td class="px-6 py-4 text-right">{formatCurrency(tx.price)}</td>
                                        <td class="px-6 py-4 text-right font-bold">{formatCurrency(tx.qty * tx.price)}</td>
                                        <td class="px-6 py-4 text-xs max-w-xs truncate" title={tx.reason}>{tx.reason}</td>
                                    </tr>
                                ))}
                            </tbody>
                        </table>
                    </div>
                )}
            </div>
        );

        const Settings = ({ marketData }) => {
            const [apiKey, setApiKey] = useState(() => localStorage.getItem('av_api_key') || '');

            const handleSave = () => {
                localStorage.setItem('av_api_key', apiKey);
                alert('API Key Saved! Please refresh to reload data.');
                window.location.reload();
            };

            return (
                <div class="bg-white dark:bg-zinc-800 border border-gray-200 dark:border-zinc-700 rounded-sm p-6 max-w-lg">
                    <h2 class="text-xl font-bold mb-4 uppercase">Data Settings</h2>
                    <div class="space-y-4">
                        <div>
                            <label class="block text-sm font-bold mb-2">Alpha Vantage API Key (US Stocks)</label>
                            <input
                                type="text"
                                value={apiKey}
                                onChange={(e) => setApiKey(e.target.value)}
                                placeholder="Enter your key..."
                                class="w-full p-2 border border-black dark:border-white bg-transparent rounded-sm text-sm font-mono"
                            />
                            <p class="text-xs text-gray-500 mt-1">Required for real-time US Stock data. <a href="https://www.alphavantage.co/support/#api-key" target="_blank" class="underline">Get Free Key</a></p>
                        </div>
                        <button onClick={handleSave} class="bg-black text-white dark:bg-white dark:text-black px-6 py-2 font-bold uppercase rounded-sm hover:opacity-80">Save Settings</button>

                        <div class="pt-6 border-t border-gray-200 dark:border-zinc-700">
                            <h3 class="text-sm font-bold mb-2">API Status</h3>
                            <ul class="text-xs space-y-2 text-gray-500 font-mono">
                                <li class="flex items-center gap-2">
                                    <span class={`w-3 h-3 rounded-full ${marketData?.crypto?.length > 0 ? 'bg-emerald-500' : 'bg-red-500'}`}></span>
                                    Crypto: CoinGecko (Public API)
                                </li>
                                <li class="flex items-center gap-2">
                                    <span class={`w-3 h-3 rounded-full ${marketData?.us?.length > 0 ? 'bg-emerald-500' : 'bg-red-500'}`}></span>
                                    US Stocks: Alpha Vantage (Key Required)
                                </li>
                                <li class="flex items-center gap-2">
                                    <span class={`w-3 h-3 rounded-full ${marketData?.pl?.length > 0 ? 'bg-emerald-500' : 'bg-red-500'}`}></span>
                                    PL Stocks: Yahoo Finance via Proxy
                                </li>
                            </ul>
                        </div>
                    </div>
                </div>
            );
        };

        const MainContent = ({ activeTab, marketData, loading, portfolio, onOpenTrade, selectedAsset, onSelectAsset }) => {
            const currentAsset = selectedAsset || (marketData.us[0] || { symbol: 'AAPL', price: 173.50, change: 1.25, name: 'Apple Inc.' });

            if (activeTab === 'Dashboard') {
                return (
                    <section class="col-span-3 space-y-8">
                        <div class="grid grid-cols-2 gap-4">
                            <div class="bg-white dark:bg-zinc-800 border border-gray-200 dark:border-zinc-700 p-6 rounded-sm shadow-sm">
                                <span class="text-xs uppercase font-bold text-gray-400">Total Equity</span>
                                <div class="text-2xl font-bold font-mono">{formatCurrency(portfolio.equity)}</div>
                            </div>
                            <div class="bg-white dark:bg-zinc-800 border border-gray-200 dark:border-zinc-700 p-6 rounded-sm shadow-sm">
                                <span class="text-xs uppercase font-bold text-gray-400">Available Cash</span>
                                <div class="text-2xl font-bold font-mono">{formatCurrency(portfolio.cash)}</div>
                            </div>
                        </div>
                        <PositionsTable positions={portfolio.positions} onOpenTrade={onOpenTrade} />
                        <MarketTable title="Top Movers" data={marketData.us.slice(0, 3)} loading={loading} onOpenTrade={onOpenTrade} onSelect={onSelectAsset} />
                    </section>
                );
            }

            if (activeTab === 'History') {
                return (
                    <section class="col-span-3 space-y-8">
                        <HistoryTable history={portfolio.history} />
                    </section>
                );
            }

            if (activeTab === 'Settings') {
                return (
                    <section class="col-span-3 space-y-8">
                        <Settings marketData={marketData} />
                    </section>
                );
            }

            let displayData = [];
            if (activeTab === 'US Markets') displayData = marketData.us;
            if (activeTab === 'Polish Stocks') displayData = marketData.pl;
            if (activeTab === 'Crypto') displayData = marketData.crypto;

            return (
                <section class="col-span-3 space-y-8">
                    {/* Dynamic Chart Area */}
                    <div class="bg-white dark:bg-zinc-800 border border-gray-200 dark:border-zinc-700 p-8 rounded-sm h-96 flex flex-col justify-between shadow-sm">
                        <div class="flex justify-between items-start mb-4">
                            <div>
                                <h2 class="text-2xl font-bold">{currentAsset.symbol}</h2>
                                <span class="font-mono text-gray-500">{currentAsset.name}</span>
                            </div>
                            <div class="text-right">
                                <div class="text-3xl font-mono font-bold">{formatCurrency(currentAsset.price)}</div>
                                <div class={`text-sm font-bold ${currentAsset.change >= 0 ? 'text-emerald-500' : 'text-red-500'}`}>{formatPct(currentAsset.change)}</div>
                            </div>
                        </div>
                        <div class="flex-1 relative w-full h-full">
                            <ChartComponent asset={currentAsset} />
                        </div>
                        <div class="flex gap-4 mt-4">
                            <button onClick={() => onOpenTrade(currentAsset)} class="flex-1 bg-black text-white dark:bg-white dark:text-black py-2 font-bold uppercase rounded-sm hover:opacity-80">Trade {currentAsset.symbol}</button>
                        </div>
                    </div>

                    <div class="bg-white dark:bg-zinc-800 border border-gray-200 dark:border-zinc-700 rounded-sm overflow-hidden shadow-sm">
                        <h2 class="text-2xl font-bold mb-2 px-4 pt-4">{activeTab}</h2>
                        <MarketTable title={`Live ${activeTab} Data`} data={displayData} loading={loading} onOpenTrade={onOpenTrade} onSelect={onSelectAsset} />
                    </div>
                </section>
            );
        };

        // --- Toast Notification Component ---
        const ToastContainer = ({ toasts }) => (
            <div class="fixed bottom-4 right-4 z-50 flex flex-col gap-2 pointer-events-none">
                {toasts.map(t => (
                    <div key={t.id} class={`p-4 rounded-sm shadow-lg border-l-4 text-sm font-bold pointer-events-auto animate-bounce ${t.type === 'error' ? 'bg-white border-red-500 text-red-600' : 'bg-white border-emerald-500 text-emerald-600'} dark:bg-zinc-800 dark:text-gray-100`}>
                        {t.message}
                    </div>
                ))}
            </div>
        );

        const App = () => {
            // Set dark mode default
            const [darkMode, setDarkMode] = useState(() => {
                const saved = localStorage.getItem('theme');
                return saved ? saved === 'dark' : true; // Default to TRUE (Dark)
            });
            const [activeTab, setActiveTab] = useState('Dashboard');
            const [loading, setLoading] = useState(true);
            const [marketData, setMarketData] = useState({ us: [], pl: [], crypto: [] });
            const [selectedAsset, setSelectedAsset] = useState(null);

            const [portfolio, setPortfolio] = useState(() => {
                const saved = localStorage.getItem('portfolio');
                return saved ? JSON.parse(saved) : { cash: 100000, positions: [], history: [], equity: 100000 };
            });
            const [tradeAsset, setTradeAsset] = useState(null);

            // Auto-Trading State
            const [autoTradeEnabled, setAutoTradeEnabled] = useState(false);
            const [toasts, setToasts] = useState([]);

            const addToast = (message, type = 'info') => {
                const id = Date.now();
                setToasts(prev => [...prev, { id, message, type }]);
                setTimeout(() => setToasts(prev => prev.filter(t => t.id !== id)), 4000);
            };

            // Trade Execution Logic (Refactored for reuse)
            const executeTrade = (asset, mode, qty, reason = "Manual Trade") => {
                const totalCost = asset.price * qty;

                // We need to use functional state update to ensure we have latest portfolio
                // But since this is called from event handler or effect, we need to be careful.
                // For simplicity in this single-file React, we'll use the 'portfolio' from closure if called manually,
                // but for Auto-Trader we might need a ref or dependency. 
                // Using setPortfolio callback style is safest.

                setPortfolio(currentPortfolio => {
                    if (mode === 'BUY') {
                        if (currentPortfolio.cash < totalCost) {
                            if (reason === "Manual Trade") alert("Insufficient Funds!");
                            return currentPortfolio; // Abort
                        }

                        const newCash = currentPortfolio.cash - totalCost;
                        const existingPos = currentPortfolio.positions.find(p => p.symbol === asset.symbol);
                        let newPositions;

                        if (existingPos) {
                            newPositions = currentPortfolio.positions.map(p =>
                                p.symbol === asset.symbol
                                    ? { ...p, qty: p.qty + qty, avgPrice: ((p.avgPrice * p.qty) + totalCost) / (p.qty + qty) }
                                    : p
                            );
                        } else {
                            newPositions = [...currentPortfolio.positions, { symbol: asset.symbol, qty, avgPrice: asset.price }];
                        }

                        if (reason !== "Manual Trade") addToast(`ü§ñ AUTO-BUY: ${asset.symbol} x${qty} | ${reason}`, 'success');

                        return {
                            ...currentPortfolio,
                            cash: newCash,
                            positions: newPositions,
                            history: [...currentPortfolio.history, { date: new Date(), type: 'BUY', symbol: asset.symbol, qty, price: asset.price, reason }]
                        };
                    } else {
                        // SELL
                        const existingPos = currentPortfolio.positions.find(p => p.symbol === asset.symbol);
                        if (!existingPos || existingPos.qty < qty) {
                            if (reason === "Manual Trade") alert("Insufficient Holdings!");
                            return currentPortfolio;
                        }

                        const newCash = currentPortfolio.cash + totalCost;
                        let newPositions;
                        if (existingPos.qty === qty) {
                            newPositions = currentPortfolio.positions.filter(p => p.symbol !== asset.symbol);
                        } else {
                            newPositions = currentPortfolio.positions.map(p =>
                                p.symbol === asset.symbol ? { ...p, qty: p.qty - qty } : p
                            );
                        }

                        if (reason !== "Manual Trade") addToast(`ü§ñ AUTO-SELL: ${asset.symbol} x${qty} | ${reason}`, 'success');

                        return {
                            ...currentPortfolio,
                            cash: newCash,
                            positions: newPositions,
                            history: [...currentPortfolio.history, { date: new Date(), type: 'SELL', symbol: asset.symbol, qty, price: asset.price, reason }]
                        };
                    }
                });
            };

            const handleManualTrade = (asset, mode, qty) => {
                executeTrade(asset, mode, qty);
                setTradeAsset(null);
            };

            // Auto-Trader Effect
            useEffect(() => {
                if (!autoTradeEnabled || loading) return;

                const interval = setInterval(() => {
                    // 1. Flatten all assets
                    const allAssets = [...marketData.us, ...marketData.pl, ...marketData.crypto];

                    allAssets.forEach(asset => {
                        if (!asset.prices || asset.prices.length < 14) return;

                        // Calculate Indicators
                        const rsi = calcRSI(asset.prices);

                        // Logic
                        // BUY if RSI < 30 (Oversold)
                        if (rsi < 30) {
                            // Check if we already hold it? (Simply don't overbuy for now - limit to 1 trade per tick per asset effectively by probability)
                            // A real engine would check 'positions' state. 
                            // Since we don't have easy access to latest 'portfolio' inside this interval without refs, 
                            // we relying on the setPortfolio callback in executeTrade which IS safe.
                            // But we might buy multiple times if RSI stays low. 
                            // Let's add a random chance to reduce frequency
                            if (Math.random() > 0.8) {
                                executeTrade(asset, 'BUY', 1, `RSI Oversold (${rsi.toFixed(0)})`);
                            }
                        }

                        // SELL if RSI > 70 (Overbought)
                        if (rsi > 70) {
                            if (Math.random() > 0.8) {
                                executeTrade(asset, 'SELL', 1, `RSI Overbought (${rsi.toFixed(0)})`);
                            }
                        }
                    });
                }, 5000); // Run every 5 seconds

                return () => clearInterval(interval);
            }, [autoTradeEnabled, loading, marketData]); // Re-create if data changes (which it doesn't really in this mock except on reload)

            // ... savePortfolio effect ...

            useEffect(() => {
                const savePortfolio = () => {
                    let positionValue = 0;
                    // We need to access the LATEST portfolio from state, but this effect runs on 'portfolio' change.
                    // So 'portfolio' here is fresh.
                    const allAssets = [...marketData.us, ...marketData.pl, ...marketData.crypto];
                    if (allAssets.length === 0) return;

                    const newPositions = portfolio.positions.map(p => {
                        const asset = allAssets.find(a => a.symbol === p.symbol);
                        const currentPrice = asset ? asset.price : p.avgPrice;
                        positionValue += p.qty * currentPrice;
                        return { ...p, currentPrice };
                    });

                    const newEquity = portfolio.cash + positionValue;
                    const updated = { ...portfolio, equity: newEquity, positions: newPositions };
                    localStorage.setItem('portfolio', JSON.stringify(updated));
                };
                if (!loading) savePortfolio();
            }, [marketData, portfolio.cash, portfolio.positions.length]); // Dependencies to update equity

            // ... theme effect ...
            useEffect(() => {
                if (darkMode) {
                    document.documentElement.classList.add('dark');
                    localStorage.setItem('theme', 'dark');
                } else {
                    document.documentElement.classList.remove('dark');
                    localStorage.setItem('theme', 'light');
                }
            }, [darkMode]);

            useEffect(() => {
                const loadData = async () => {
                    setLoading(true);
                    const [us, pl, crypto] = await Promise.all([
                        fetchUSStocks(),
                        fetchPLStocks(),
                        fetchCrypto()
                    ]);
                    setMarketData({ us, pl, crypto });
                    setLoading(false);
                };
                loadData();
            }, []);

            return (
                <div class="container mx-auto p-4 max-w-7xl">
                    <div class="fixed top-4 right-4 z-40">
                        <button
                            onClick={() => setAutoTradeEnabled(!autoTradeEnabled)}
                            class={`px-4 py-2 font-bold rounded-sm border-2 ${autoTradeEnabled ? 'bg-emerald-500 text-white border-emerald-500 animate-pulse' : 'bg-gray-200 text-gray-500 border-gray-300'}`}
                        >
                            {autoTradeEnabled ? 'ü§ñ AUTO-TRADING ON' : 'ü§ñ AUTO-TRADING OFF'}
                        </button>
                    </div>

                    <Header darkMode={darkMode} toggleTheme={() => setDarkMode(!darkMode)} portfolio={portfolio} />
                    <main class="grid grid-cols-1 md:grid-cols-4 gap-8">
                        <Sidebar activeTab={activeTab} setActiveTab={setActiveTab} />
                        <MainContent
                            activeTab={activeTab}
                            marketData={marketData}
                            loading={loading}
                            portfolio={portfolio}
                            onOpenTrade={setTradeAsset}
                            selectedAsset={selectedAsset}
                            onSelectAsset={setSelectedAsset}
                        />
                    </main>
                    <TradeModal isOpen={!!tradeAsset} asset={tradeAsset} onClose={() => setTradeAsset(null)} onTrade={handleManualTrade} />
                    <ToastContainer toasts={toasts} />
                </div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>

</html>