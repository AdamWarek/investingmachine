<!DOCTYPE html>
<html lang="en" class="dark">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Trade.io - Virtual Trading</title>

    <!-- React & ReactDOM -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>

    <!-- Babel for JSX -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            darkMode: 'class',
            theme: {
                extend: {
                    fontFamily: {
                        sans: ['Helvetica', 'Arial', 'sans-serif'],
                        mono: ['ui-monospace', 'SFMono-Regular', 'Menlo', 'Monaco', 'Consolas', "Liberation Mono", "Courier New", 'monospace'],
                    },
                    colors: {
                        swiss: {
                            red: '#ef4444',
                            green: '#10b981',
                            dark: '#18181b',
                            light: '#f4f4f5'
                        }
                    }
                }
            }
        }
    </script>

    <!-- Chart.js -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

    <style>
        body {
            font-family: 'Helvetica', 'Arial', sans-serif;
        }

        .card {
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.05);
        }
    </style>
</head>

<body class="bg-gray-100 dark:bg-zinc-900 text-gray-900 dark:text-gray-100 min-h-screen transition-colors duration-200">
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useMemo } = React;

        // Helper to generate mock history
        // Helper to generate mock history
        const generateHistory = (currentPrice) => {
            const history = [];
            const now = new Date();
            let p = currentPrice;
            const dates = [];
            const prices = [];
            const opens = [];
            const highs = [];
            const lows = [];
            const volumes = [];

            // Generate 60 days of history for indicators (ADX needs valid history)
            for (let i = 0; i <= 60; i++) {
                const date = new Date(now);
                date.setDate(date.getDate() - i);
                dates.unshift(date.toLocaleDateString());

                // Random variation
                const change = (Math.random() - 0.5) * 0.04;
                const open = p;
                const close = p / (1 + change);
                const high = Math.max(open, close) * (1 + Math.random() * 0.01);
                const low = Math.min(open, close) * (1 - Math.random() * 0.01);
                const volume = Math.floor(Math.random() * 1000000) + 500000;

                prices.unshift(close);
                opens.unshift(open);
                highs.unshift(high);
                lows.unshift(low);
                volumes.unshift(volume);

                p = close; // walk back
            }

            // Re-align to current price being the last one
            prices[prices.length - 1] = currentPrice;

            return { dates, prices, opens, highs, lows, volumes };
        };

        // --- Mock Data & Utilities ---
        const formatCurrency = (val) => new Intl.NumberFormat('en-US', { style: 'currency', currency: 'USD' }).format(val);
        const formatPct = (val) => (val > 0 ? '+' : '') + val.toFixed(2) + '%';

        // --- API & Data Logic ---
        // Cache Helpers
        const getCached = (key) => {
            const item = localStorage.getItem(key);
            if (!item) return null;
            const { data, timestamp } = JSON.parse(item);
            // 60 minutes cache for API data to save limits
            if (Date.now() - timestamp > 60 * 60 * 1000) return null;
            return data;
        };

        const setCache = (key, data) => {
            localStorage.setItem(key, JSON.stringify({ data, timestamp: Date.now() }));
        };

        // Crypto: CoinGecko (Public)
        const fetchCrypto = async () => {
            const cacheKey = 'data_crypto_real';
            const cached = getCached(cacheKey);
            if (cached) return cached;

            try {
                const res = await fetch('https://api.coingecko.com/api/v3/coins/markets?vs_currency=usd&ids=bitcoin,ethereum,solana,cardano,ripple&order=market_cap_desc&per_page=5&page=1&sparkline=false');
                if (!res.ok) throw new Error('CoinGecko API limit');
                const data = await res.json();

                const mapped = data.map(coin => ({
                    symbol: coin.symbol.toUpperCase(),
                    price: coin.current_price,
                    change: coin.price_change_percentage_24h,
                    name: coin.name,
                    ...generateHistory(coin.current_price) // Still sim history for chart consistency unless we fetch candles
                }));

                setCache(cacheKey, mapped);
                return mapped;
            } catch (err) {
                console.warn("Crypto fetch failed, using fallback", err);
                return [
                    { symbol: 'BTC', price: 64230, change: 2.4, name: 'Bitcoin', ...generateHistory(64230) },
                    { symbol: 'ETH', price: 3450, change: -1.2, name: 'Ethereum', ...generateHistory(3450) },
                    { symbol: 'SOL', price: 145, change: 5.4, name: 'Solana', ...generateHistory(145) }
                ];
            }
        };

        // US Stocks: Yahoo Finance via Proxy (No Key Required)
        const fetchUSStocks = async () => {










            const symbols = ['AAPL', 'NVDA', 'TSLA', 'MSFT', 'GOOGL', 'AMZN', 'META', 'AMD'];
            const cacheKey = 'data_us_real_yahoo';
            const cached = getCached(cacheKey);
            if (cached) return cached;

            try {
                const results = [];
                const proxyUrl = 'https://api.allorigins.win/get?url=';

                for (const symbol of symbols) {
                    const targetUrl = encodeURIComponent(`https://query1.finance.yahoo.com/v8/finance/chart/${symbol}?interval=1d&range=1d`);
                    const res = await fetch(proxyUrl + targetUrl);
                    const data = await res.json();
                    if (data.contents) {
                        const parsed = JSON.parse(data.contents);
                        const meta = parsed.chart.result[0].meta;
                        const price = meta.regularMarketPrice;
                        const prevClose = meta.chartPreviousClose;
                        const change = ((price - prevClose) / prevClose) * 100;

                        results.push({
                            symbol: symbol,
                            price: price,
                            change: change,
                            name: symbol,
                            ...generateHistory(price)
                        });
                    }
                }

                if (results.length > 0) {
                    setCache(cacheKey, results);
                    return results;
                }
                throw new Error("No data from Yahoo Proxy for US");

            } catch (err) {
                console.warn("US Stock fetch failed", err);
                return [
                    { symbol: 'AAPL', price: 173.50, change: 1.24, name: 'Apple Inc.', ...generateHistory(173.50) },
                    { symbol: 'NVDA', price: 885.20, change: 3.50, name: 'NVIDIA Corp.', ...generateHistory(885.20) },
                    { symbol: 'TSLA', price: 178.50, change: -0.45, name: 'Tesla Inc.', ...generateHistory(178.50) }
                ];
            }
        };

        // Polish Stocks: Yahoo Finance via Proxy
        const fetchPLStocks = async () => {
            const symbols = ['PKO.WA', 'KGH.WA', 'CDR.WA', 'ALE.WA'];
            const cacheKey = 'data_pl_real';
            const cached = getCached(cacheKey);
            if (cached) return cached;

            try {
                const results = [];
                // Using allorigins.win or corsproxy.io
                // Yahoo query: https://query1.finance.yahoo.com/v8/finance/chart/PKO.WA?interval=1d&range=1d

                const proxyUrl = 'https://api.allorigins.win/get?url=';

                for (const symbol of symbols) {
                    const targetUrl = encodeURIComponent(`https://query1.finance.yahoo.com/v8/finance/chart/${symbol}?interval=1d&range=1d`);
                    const res = await fetch(proxyUrl + targetUrl);
                    const data = await res.json();
                    if (data.contents) {
                        const parsed = JSON.parse(data.contents);
                        const meta = parsed.chart.result[0].meta;
                        const price = meta.regularMarketPrice;
                        const prevClose = meta.chartPreviousClose;
                        const change = ((price - prevClose) / prevClose) * 100;

                        results.push({
                            symbol: symbol.replace('.WA', ''),
                            price: price,
                            change: change,
                            name: symbol,
                            ...generateHistory(price)
                        });
                    }
                }

                if (results.length > 0) {
                    setCache(cacheKey, results);
                    return results;
                }
                throw new Error("No data from Yahoo Proxy");

            } catch (err) {
                console.warn("PL Stock fetch failed", err);
                return [
                    { symbol: 'PKO', price: 45.20, change: 1.10, name: 'PKO BP', ...generateHistory(45.20) },
                    { symbol: 'KGH', price: 120.50, change: -2.30, name: 'KGHM', ...generateHistory(120.50) },
                    { symbol: 'CDR', price: 115.00, change: 0.50, name: 'CD Projekt', ...generateHistory(115.00) }
                ];
            }
        };

        // --- Technical Indicators ---

        const calcSMA = (data, period) => {
            if (data.length < period) return null;
            const sum = data.slice(data.length - period).reduce((a, b) => a + b, 0);
            return sum / period;
        };

        const calcStdDev = (data, period, sma) => {
            if (data.length < period) return 0;
            const slice = data.slice(data.length - period);
            const mean = sma || calcSMA(data, period);
            const sqDiffs = slice.map(v => Math.pow(v - mean, 2));
            const avgSqDiff = sqDiffs.reduce((a, b) => a + b, 0) / period;
            return Math.sqrt(avgSqDiff);
        };

        const calcBollingerBands = (prices, period = 20, multiplier = 2) => {
            const sma = calcSMA(prices, period);
            if (!sma) return null;
            const stdDev = calcStdDev(prices, period, sma);
            return {
                middle: sma,
                upper: sma + (stdDev * multiplier),
                lower: sma - (stdDev * multiplier)
            };
        };

        const calcEMA = (prices, period) => {
            if (prices.length < period) return null;
            const k = 2 / (period + 1);
            // Start with SMA for first EMA
            let ema = prices.slice(0, period).reduce((a, b) => a + b, 0) / period;
            for (let i = period; i < prices.length; i++) {
                ema = (prices[i] * k) + (ema * (1 - k));
            }
            return ema;
        };

        const calcRSI = (closes, period = 14) => {
            if (closes.length < period + 1) return 50;
            let gains = 0, losses = 0;
            // First average
            for (let i = 1; i <= period; i++) {
                const change = closes[i] - closes[i - 1];
                if (change > 0) gains += change;
                else losses -= change;
            }
            let avgGain = gains / period;
            let avgLoss = losses / period;

            // Smoothed
            for (let i = period + 1; i < closes.length; i++) {
                const change = closes[i] - closes[i - 1];
                const gain = change > 0 ? change : 0;
                const loss = change < 0 ? -change : 0;
                avgGain = (avgGain * (period - 1) + gain) / period;
                avgLoss = (avgLoss * (period - 1) + loss) / period;
            }

            if (avgLoss === 0) return 100;
            const rs = avgGain / avgLoss;
            return 100 - (100 / (1 + rs));
        };

        const calcMACD = (closes) => {
            if (closes.length < 26) return { macd: 0, signal: 0, histogram: 0 };

            const ema12 = [];
            const ema26 = [];
            const macdLine = [];

            // Calculate EMA12 series
            let k12 = 2 / (12 + 1);
            let e12 = closes.slice(0, 12).reduce((a, b) => a + b, 0) / 12;
            for (let i = 12; i < closes.length; i++) {
                e12 = (closes[i] * k12) + (e12 * (1 - k12));
                ema12[i] = e12;
            }

            // Calculate EMA26 series
            let k26 = 2 / (26 + 1);
            let e26 = closes.slice(0, 26).reduce((a, b) => a + b, 0) / 26;
            for (let i = 26; i < closes.length; i++) {
                e26 = (closes[i] * k26) + (e26 * (1 - k26));
                ema26[i] = e26;
            }

            // MACD Line = EMA12 - EMA26
            for (let i = 26; i < closes.length; i++) {
                macdLine.push((ema12[i] || 0) - (ema26[i] || 0));
            }

            // Signal Line = EMA9 of MACD Line
            if (macdLine.length < 9) return { macd: 0, signal: 0, histogram: 0 };

            const k9 = 2 / (9 + 1);
            let signal = macdLine.slice(0, 9).reduce((a, b) => a + b, 0) / 9;
            for (let i = 9; i < macdLine.length; i++) {
                signal = (macdLine[i] * k9) + (signal * (1 - k9));
            }

            const currentMacd = macdLine[macdLine.length - 1];
            return {
                macd: currentMacd,
                signal: signal,
                histogram: currentMacd - signal,
                // Approximation for trend
                prevMacd: macdLine[macdLine.length - 2],
                prevSignal: signal // Ideally this should be prev signal
            };
        };

        const calcADX = (highs, lows, closes, period = 14) => {
            if (highs.length < period * 2) return 20; // Default if not enough data

            const trs = [];
            const dmPlus = [];
            const dmMinus = [];

            for (let i = 1; i < highs.length; i++) {
                const up = highs[i] - highs[i - 1];
                const down = lows[i - 1] - lows[i];

                dmPlus.push((up > down && up > 0) ? up : 0);
                dmMinus.push((down > up && down > 0) ? down : 0);

                const tr = Math.max(
                    highs[i] - lows[i],
                    Math.abs(highs[i] - closes[i - 1]),
                    Math.abs(lows[i] - closes[i - 1])
                );
                trs.push(tr);
            }

            // Smoothed
            let smTR = trs.slice(0, period).reduce((a, b) => a + b, 0);
            let smDMPlus = dmPlus.slice(0, period).reduce((a, b) => a + b, 0);
            let smDMMinus = dmMinus.slice(0, period).reduce((a, b) => a + b, 0);

            const dxs = [];

            for (let i = period; i < trs.length; i++) {
                smTR = smTR - (smTR / period) + trs[i];
                smDMPlus = smDMPlus - (smDMPlus / period) + dmPlus[i];
                smDMMinus = smDMMinus - (smDMMinus / period) + dmMinus[i];

                const diPlus = smTR === 0 ? 0 : (smDMPlus / smTR) * 100;
                const diMinus = smTR === 0 ? 0 : (smDMMinus / smTR) * 100;

                const sumDi = diPlus + diMinus;
                const dx = sumDi === 0 ? 0 : (Math.abs(diPlus - diMinus) / sumDi) * 100;
                dxs.push(dx);
            }

            // ADX is EMA of DX
            if (dxs.length < period) return dxs[dxs.length - 1] || 20;

            let adx = dxs.slice(0, period).reduce((a, b) => a + b, 0) / period;
            for (let i = period; i < dxs.length; i++) {
                adx = ((adx * (period - 1)) + dxs[i]) / period;
            }

            return adx;
        };

        // --- Components ---

        const TradeModal = ({ isOpen, onClose, asset, onTrade }) => {
            if (!isOpen || !asset) return null;
            const [qty, setQty] = useState(1);
            const [mode, setMode] = useState('BUY'); // BUY or SELL

            const total = qty * asset.price;

            return (
                <div class="fixed inset-0 bg-black/50 flex items-center justify-center p-4 z-50">
                    <div class="bg-white dark:bg-zinc-900 border border-black dark:border-white p-6 max-w-sm w-full shadow-2xl rounded-sm">
                        <h2 class="text-xl font-bold mb-4 uppercase">{mode} {asset.symbol}</h2>

                        <div class="flex gap-2 mb-4">
                            <button onClick={() => setMode('BUY')} class={`flex-1 py-2 font-bold ${mode === 'BUY' ? 'bg-black text-white dark:bg-white dark:text-black' : 'bg-gray-200 text-gray-500'}`}>BUY</button>
                            <button onClick={() => setMode('SELL')} class={`flex-1 py-2 font-bold ${mode === 'SELL' ? 'bg-black text-white dark:bg-white dark:text-black' : 'bg-gray-200 text-gray-500'}`}>SELL</button>
                        </div>

                        <div class="space-y-4 font-mono text-sm">
                            <div class="flex justify-between">
                                <span>Price:</span>
                                <span>{formatCurrency(asset.price)}</span>
                            </div>
                            <div class="flex justify-between items-center">
                                <span>Quantity:</span>
                                <input type="number" min="1" value={qty} onChange={e => setQty(Number(e.target.value))} class="w-20 p-1 border border-gray-300 dark:border-zinc-700 bg-transparent text-right" />
                            </div>
                            <div class="flex justify-between border-t border-gray-300 dark:border-zinc-700 pt-2 font-bold">
                                <span>Total:</span>
                                <span>{formatCurrency(total)}</span>
                            </div>
                        </div>

                        <div class="mt-6 flex gap-2">
                            <button onClick={onClose} class="flex-1 py-2 border border-gray-300 dark:border-zinc-700 font-bold hover:bg-gray-100 dark:hover:bg-zinc-800">CANCEL</button>
                            <button onClick={() => onTrade(asset, mode, qty)} class="flex-1 py-2 bg-emerald-500 text-white font-bold hover:bg-emerald-600">CONFIRM</button>
                        </div>
                    </div>
                </div>
            );
        };

        const Header = ({ darkMode, toggleTheme, portfolio }) => (
            <header class="flex justify-between items-end mb-8 border-b-2 border-black dark:border-white pb-4 px-8 pt-6">
                <div>
                    <h1 class="text-4xl font-extrabold tracking-tighter uppercase dark:text-white">Trade<span class="text-gray-400">.io</span></h1>
                    <p class="text-sm text-gray-500 dark:text-gray-400 mt-1">Professional Trading Environment</p>
                </div>
                <div class="flex items-end gap-8">
                    <div class="text-right">
                        <div class="text-xs uppercase font-bold text-gray-400 tracking-widest mb-1">Total Equity</div>
                        <div class="text-3xl font-bold font-mono tracking-tight">{formatCurrency(portfolio.equity)}</div>
                        <div class="text-sm font-medium mt-1 flex items-center justify-end gap-1 font-mono">
                            <span class="text-gray-500">Cash: {formatCurrency(portfolio.cash)}</span>
                        </div>
                    </div>
                    <button onClick={toggleTheme} class="p-2 rounded-full hover:bg-gray-200 dark:hover:bg-zinc-800 transition">
                        {darkMode ? '‚òÄÔ∏è' : 'üåô'}
                    </button>
                </div>
            </header>
        );

        const Sidebar = ({ activeTab, setActiveTab }) => (
            <aside class="col-span-1 space-y-6">
                <nav class="space-y-1">
                    {['Dashboard', 'Beginner Stats', 'US Markets', 'Polish Stocks', 'Crypto', 'History', 'Settings'].map(tab => (
                        <button
                            key={tab}
                            onClick={() => setActiveTab(tab)}
                            class={`w-full text-left block px-4 py-3 font-bold rounded-sm transition ${activeTab === tab
                                ? 'bg-black dark:bg-white text-white dark:text-black'
                                : 'hover:bg-gray-200 dark:hover:bg-zinc-800'
                                }`}
                        >
                            {tab}
                        </button>
                    ))}
                </nav>
            </aside>
        );

        const ChartComponent = ({ asset }) => {
            const canvasRef = React.useRef(null);
            const chartRef = React.useRef(null);

            React.useEffect(() => {
                if (!canvasRef.current || !asset) return;

                const ctx = canvasRef.current.getContext('2d');

                // Destroy previous chart
                if (chartRef.current) {
                    chartRef.current.destroy();
                }

                // Generate mock history for the chart based on current price
                const history = [];
                let price = asset.price;
                const now = new Date();
                for (let i = 30; i >= 0; i--) {
                    const date = new Date(now);
                    date.setDate(date.getDate() - i);
                    // Random walk
                    price = price * (1 + (Math.random() - 0.5) * 0.05);
                    history.push({ date: date.toLocaleDateString(), price });
                }
                // Ensure last point matches current
                history[history.length - 1].price = asset.price;

                chartRef.current = new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels: history.map(h => h.date),
                        datasets: [{
                            label: 'Price (USD)',
                            data: history.map(h => h.price),
                            borderColor: asset.change >= 0 ? '#10b981' : '#ef4444',
                            backgroundColor: (context) => {
                                const ctx = context.chart.ctx;
                                const gradient = ctx.createLinearGradient(0, 0, 0, 300);
                                gradient.addColorStop(0, asset.change >= 0 ? 'rgba(16, 185, 129, 0.2)' : 'rgba(239, 68, 68, 0.2)');
                                gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
                                return gradient;
                            },
                            borderWidth: 2,
                            fill: true,
                            tension: 0.4,
                            pointRadius: 0
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: { display: false },
                            tooltip: {
                                mode: 'index',
                                intersect: false,
                                callbacks: { label: (ctx) => formatCurrency(ctx.raw) }
                            }
                        },
                        scales: {
                            x: { display: false },
                            y: {
                                display: true,
                                position: 'right',
                                grid: { color: '#33333333' }
                            }
                        },
                        interaction: {
                            mode: 'nearest',
                            axis: 'x',
                            intersect: false
                        }
                    }
                });

                return () => {
                    if (chartRef.current) chartRef.current.destroy();
                };
            }, [asset]); // Re-render when asset changes

            return <canvas ref={canvasRef} />;
        };

        const MarketTable = ({ title, data, loading, onOpenTrade, onSelect }) => (
            <div class="bg-white dark:bg-zinc-800 border border-gray-200 dark:border-zinc-700 rounded-sm overflow-hidden shadow-sm">
                <div class="p-4 border-b border-gray-200 dark:border-zinc-700 font-bold uppercase tracking-wider text-sm">{title}</div>
                <table class="w-full text-left">
                    <thead class="bg-gray-50 dark:bg-zinc-900 border-b border-gray-200 dark:border-zinc-700">
                        <tr class="text-xs font-bold text-gray-500 uppercase tracking-wider">
                            <th class="px-6 py-4">Instrument</th>
                            <th class="px-6 py-4">Price</th>
                            <th class="px-6 py-4">Change</th>
                            <th class="px-6 py-4 text-right">Action</th>
                        </tr>
                    </thead>
                    <tbody class="divide-y divide-gray-100 dark:divide-zinc-700 font-mono text-sm">
                        {loading ? (
                            <tr><td colSpan="4" class="p-6 text-center text-gray-500">Loading market data...</td></tr>
                        ) : data.map((item, idx) => (
                            <tr key={idx} onClick={() => onSelect && onSelect(item)} class="hover:bg-gray-50 dark:hover:bg-zinc-700/50 transition cursor-pointer">
                                <td class="px-6 py-4 font-bold text-sans">
                                    <div class="font-bold">{item.symbol}</div>
                                    <div class="text-xs text-gray-500 dark:text-gray-400 font-sans">{item.name}</div>
                                </td>
                                <td class="px-6 py-4">{formatCurrency(item.price)}</td>
                                <td class={`px-6 py-4 ${item.change >= 0 ? 'text-emerald-500' : 'text-red-500'}`}>
                                    {formatPct(item.change)}
                                </td>
                                <td class="px-6 py-4 text-right">
                                    <button onClick={(e) => { e.stopPropagation(); onOpenTrade(item); }} class="bg-black dark:bg-white text-white dark:text-black hover:opacity-80 px-4 py-1 rounded-sm text-xs font-bold uppercase">Trade</button>
                                </td>
                            </tr>
                        ))}
                    </tbody>
                </table>
            </div>
        );

        const PositionsTable = ({ positions, onOpenTrade }) => (
            <div class="bg-white dark:bg-zinc-800 border border-gray-200 dark:border-zinc-700 rounded-sm overflow-hidden shadow-sm">
                <div class="p-4 border-b border-gray-200 dark:border-zinc-700 font-bold uppercase tracking-wider text-sm">Active Positions</div>
                {positions.length === 0 ? (
                    <div class="p-8 text-center text-gray-500">No active positions</div>
                ) : (
                    <table class="w-full text-left">
                        <thead class="bg-gray-50 dark:bg-zinc-900 border-b border-gray-200 dark:border-zinc-700">
                            <tr class="text-xs font-bold text-gray-500 uppercase tracking-wider">
                                <th class="px-6 py-4">Instrument</th>
                                <th class="px-6 py-4">Qty</th>
                                <th class="px-6 py-4">Avg Buy</th>
                                <th class="px-6 py-4">Current</th>
                                <th class="px-6 py-4 text-right">Value</th>
                                <th class="px-6 py-4 text-right">Action</th>
                            </tr>
                        </thead>
                        <tbody class="divide-y divide-gray-100 dark:divide-zinc-700 font-mono text-sm">
                            {positions.map((pos, idx) => (
                                <tr key={idx} class="hover:bg-gray-50 dark:hover:bg-zinc-700/50 transition">
                                    <td class="px-6 py-4 font-bold text-sans">{pos.symbol}</td>
                                    <td class="px-6 py-4">{pos.qty}</td>
                                    <td class="px-6 py-4">{formatCurrency(pos.avgPrice)}</td>
                                    <td class="px-6 py-4">{formatCurrency(pos.currentPrice || pos.avgPrice)}</td>
                                    <td class="px-6 py-4 text-right font-bold">{formatCurrency(pos.qty * (pos.currentPrice || pos.avgPrice))}</td>
                                    <td class="px-6 py-4 text-right">
                                        <button onClick={() => onOpenTrade({ symbol: pos.symbol, price: pos.currentPrice || pos.avgPrice })} class="bg-black dark:bg-white text-white dark:text-black hover:opacity-80 px-4 py-1 rounded-sm text-xs font-bold uppercase">Trade</button>
                                    </td>
                                </tr>
                            ))}
                        </tbody>
                    </table>
                )}
            </div>
        );

        const HistoryTable = ({ history }) => (
            <div class="bg-white dark:bg-zinc-800 border border-gray-200 dark:border-zinc-700 rounded-sm overflow-hidden shadow-sm">
                <div class="p-4 border-b border-gray-200 dark:border-zinc-700 font-bold uppercase tracking-wider text-sm">Transaction History</div>
                {history.length === 0 ? (
                    <div class="p-8 text-center text-gray-500">No transactions yet</div>
                ) : (
                    <div class="overflow-x-auto">
                        <table class="w-full text-left">
                            <thead class="bg-gray-50 dark:bg-zinc-900 border-b border-gray-200 dark:border-zinc-700">
                                <tr class="text-xs font-bold text-gray-500 uppercase tracking-wider">
                                    <th class="px-6 py-4">Date</th>
                                    <th class="px-6 py-4">Type</th>
                                    <th class="px-6 py-4">Instrument</th>
                                    <th class="px-6 py-4">Qty</th>
                                    <th class="px-6 py-4 text-right">Price</th>
                                    <th class="px-6 py-4 text-right">Total</th>
                                    <th class="px-6 py-4">Reason</th>
                                </tr>
                            </thead>
                            <tbody class="divide-y divide-gray-100 dark:divide-zinc-700 font-mono text-sm">
                                {history.slice().reverse().map((tx, idx) => (
                                    <tr key={idx} class="hover:bg-gray-50 dark:hover:bg-zinc-700/50 transition">
                                        <td class="px-6 py-4 text-xs text-gray-500">{new Date(tx.date).toLocaleString()}</td>
                                        <td class={`px-6 py-4 font-bold ${tx.type === 'BUY' ? 'text-emerald-500' : 'text-red-500'}`}>{tx.type}</td>
                                        <td class="px-6 py-4 font-bold">{tx.symbol}</td>
                                        <td class="px-6 py-4">{tx.qty}</td>
                                        <td class="px-6 py-4 text-right">{formatCurrency(tx.price)}</td>
                                        <td class="px-6 py-4 text-right font-bold">{formatCurrency(tx.qty * tx.price)}</td>
                                        <td class="px-6 py-4 text-xs max-w-xs truncate" title={tx.reason}>{tx.reason}</td>
                                    </tr>
                                ))}
                            </tbody>
                        </table>
                    </div>
                )}
            </div>
        );

        const Settings = ({ marketData }) => {
            const getStatusColor = (data) => data && data.length > 0 ? 'bg-emerald-500' : 'bg-red-500';

            return (
                <div class="bg-white dark:bg-zinc-800 border border-gray-200 dark:border-zinc-700 rounded-sm p-6 max-w-lg">
                    <h2 class="text-xl font-bold mb-4 uppercase">Data Settings</h2>
                    <div class="space-y-4">
                        <div class="p-4 bg-gray-50 dark:bg-zinc-900 rounded-sm">
                            <h3 class="font-bold mb-2">Data Source Configuration</h3>
                            <p class="text-sm text-gray-600 dark:text-gray-400">
                                We are now using <strong>Yahoo Finance (via Proxy)</strong> and <strong>CoinGecko</strong>.
                                No API Keys are required for standard usage!
                            </p>
                        </div>

                        <div class="pt-6 border-t border-gray-200 dark:border-zinc-700">
                            <h3 class="text-sm font-bold mb-2">API Status</h3>
                            <ul class="text-xs space-y-2 text-gray-500 font-mono">
                                <li class="flex items-center gap-2">
                                    <span class={`w-3 h-3 rounded-full ${marketData?.crypto?.length > 0 ? 'bg-emerald-500' : 'bg-red-500'}`}></span>
                                    Crypto: CoinGecko (Public API)
                                </li>
                                <li class="flex items-center gap-2">
                                    <span class={`w-3 h-3 rounded-full ${marketData?.us?.length > 0 ? 'bg-emerald-500' : 'bg-red-500'}`}></span>
                                    US Stocks: Yahoo Finance via Proxy
                                </li>
                                <li class="flex items-center gap-2">
                                    <span class={`w-3 h-3 rounded-full ${marketData?.pl?.length > 0 ? 'bg-emerald-500' : 'bg-red-500'}`}></span>
                                    PL Stocks: Yahoo Finance via Proxy
                                </li>
                            </ul>
                        </div>
                    </div>
                </div>
            );
        };

        const BeginnerStats = ({ portfolio, marketData }) => {
            // Aggregate data
            const stats = useMemo(() => {
                const uniqueSymbols = new Set([
                    ...portfolio.history.map(h => h.symbol),
                    ...portfolio.positions.map(p => p.symbol)
                ]);

                // Exclude 'USD' (Cash deposits)
                uniqueSymbols.delete('USD');

                const computed = [];
                const allMarketAssets = [...(marketData.us || []), ...(marketData.pl || []), ...(marketData.crypto || [])];

                uniqueSymbols.forEach(symbol => {
                    // Filter history for this symbol
                    const txs = portfolio.history.filter(h => h.symbol === symbol);

                    let totalInvested = 0;
                    let totalSold = 0;
                    let totalQtyBuys = 0;

                    txs.forEach(tx => {
                        if (tx.type === 'BUY') {
                            totalInvested += tx.qty * tx.price;
                            totalQtyBuys += tx.qty;
                        } else if (tx.type === 'SELL') {
                            totalSold += tx.qty * tx.price;
                        }
                    });

                    // Current Position Value
                    const pos = portfolio.positions.find(p => p.symbol === symbol);
                    // Get real-time price if available, else use pos.avgPrice or last known
                    const marketAsset = allMarketAssets.find(a => a.symbol === symbol);
                    const currentPrice = marketAsset ? marketAsset.price : (pos ? pos.avgPrice : 0);

                    const openQty = pos ? pos.qty : 0;
                    const currentValue = openQty * currentPrice;

                    // Total P/L = (Returned + CurrentValue) - Invested
                    const totalPL = (totalSold + currentValue) - totalInvested;
                    const isProfitable = totalPL >= 0;

                    computed.push({
                        symbol,
                        name: marketAsset ? marketAsset.name : symbol,
                        totalInvested,
                        totalSold,
                        currentValue,
                        totalPL,
                        isProfitable,
                        openQty
                    });
                });

                return computed.sort((a, b) => b.totalPL - a.totalPL); // Best first
            }, [portfolio, marketData]);

            return (
                <div class="space-y-6">
                    <div class="bg-gradient-to-r from-indigo-500 to-purple-600 p-8 rounded-lg text-white shadow-lg mb-8">
                        <h2 class="text-3xl font-bold mb-2">Your Investing Journey</h2>
                        <p class="opacity-90">Keep track of your total profits and losses for each asset. Green means you made money, Red means you lost money.</p>
                    </div>

                    <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
                        {stats.map(stat => (
                            <div key={stat.symbol} class="bg-white dark:bg-zinc-800 border-2 rounded-xl p-6 shadow-sm hover:shadow-md transition relative overflow-hidden group">
                                <div class={`absolute top-0 left-0 w-2 h-full ${stat.isProfitable ? 'bg-emerald-500' : 'bg-red-500'}`}></div>

                                <div class="flex justify-between items-start mb-4 pl-4">
                                    <div>
                                        <h3 class="text-2xl font-bold">{stat.symbol}</h3>
                                        <p class="text-xs text-gray-500 font-bold uppercase">{stat.name}</p>
                                    </div>
                                    <div class={`text-xs font-bold px-2 py-1 rounded ${stat.openQty > 0 ? 'bg-blue-100 text-blue-700' : 'bg-gray-100 text-gray-500'}`}>
                                        {stat.openQty > 0 ? 'ACTIVE' : 'CLOSED'}
                                    </div>
                                </div>

                                <div class="pl-4 space-y-4">
                                    <div>
                                        <p class="text-xs font-bold text-gray-400 uppercase tracking-wider">Total Profit / Loss</p>
                                        <p class={`text-3xl font-bold font-mono ${stat.isProfitable ? 'text-emerald-500' : 'text-red-500'}`}>
                                            {stat.totalPL >= 0 ? '+' : ''}{formatCurrency(stat.totalPL)}
                                        </p>
                                    </div>

                                    <div class="grid grid-cols-2 gap-4 text-sm pt-4 border-t border-gray-100 dark:border-zinc-700">
                                        <div>
                                            <p class="text-xs text-gray-400">Total Invested</p>
                                            <p class="font-bold">{formatCurrency(stat.totalInvested)}</p>
                                        </div>
                                        <div>
                                            <p class="text-xs text-gray-400">Current Value</p>
                                            <p class="font-bold">{formatCurrency(stat.currentValue + stat.totalSold)} <span class="text-[10px] opacity-60">(Inc. Sold)</span></p>
                                        </div>
                                    </div>

                                    <div class={`p-3 rounded text-sm font-bold text-center ${stat.isProfitable ? 'bg-emerald-50 text-emerald-700 dark:bg-emerald-900/20 dark:text-emerald-400' : 'bg-red-50 text-red-700 dark:bg-red-900/20 dark:text-red-400'}`}>
                                        {stat.isProfitable
                                            ? "üéâ Great job! You are in profit."
                                            : "üìâ Currently down. Persistence is key!"}
                                    </div>
                                </div>
                            </div>
                        ))}
                    </div>
                    {stats.length === 0 && (
                        <div class="text-center p-12 bg-gray-50 dark:bg-zinc-800/50 rounded-lg dashed-border">
                            <h3 class="text-xl font-bold text-gray-400">No trading history yet</h3>
                            <p class="text-gray-500 mt-2">Make your first trade to see statistics here!</p>
                        </div>
                    )}
                </div>
            );
        };

        const AddCashModal = ({ isOpen, onClose, onAddCash }) => {
            if (!isOpen) return null;
            const [amount, setAmount] = useState('');

            const handleSubmit = (e) => {
                e.preventDefault();
                const val = parseFloat(amount);
                if (val > 0) {
                    onAddCash(val);
                    setAmount('');
                    onClose();
                } else {
                    alert("Please enter a valid amount.");
                }
            };

            return (
                <div class="fixed inset-0 bg-black/50 flex items-center justify-center p-4 z-[60]">
                    <div class="bg-white dark:bg-zinc-900 border border-black dark:border-white p-6 max-w-sm w-full shadow-2xl rounded-sm">
                        <h2 class="text-xl font-bold mb-4 uppercase">Add Cash</h2>
                        <form onSubmit={handleSubmit} class="space-y-4 font-mono text-sm">
                            <div class="space-y-2">
                                <label class="block font-bold">Amount (USD)</label>
                                <input
                                    type="number"
                                    min="1"
                                    step="0.01"
                                    value={amount}
                                    onChange={e => setAmount(e.target.value)}
                                    placeholder="e.g. 5000"
                                    class="w-full p-2 border border-black dark:border-white bg-transparent rounded-sm"
                                    autoFocus
                                />
                            </div>
                            <div class="flex gap-2 pt-2">
                                <button type="button" onClick={onClose} class="flex-1 py-2 border border-gray-300 dark:border-zinc-700 font-bold hover:bg-gray-100 dark:hover:bg-zinc-800">CANCEL</button>
                                <button type="submit" class="flex-1 py-2 bg-emerald-500 text-white font-bold hover:bg-emerald-600">ADD FUNDS</button>
                            </div>
                        </form>
                    </div>
                </div>
            );
        };

        const MainContent = ({ activeTab, marketData, loading, portfolio, onOpenTrade, selectedAsset, onSelectAsset, onOpenAddCash }) => {
            const currentAsset = selectedAsset || (marketData.us[0] || { symbol: 'AAPL', price: 173.50, change: 1.25, name: 'Apple Inc.' });

            if (activeTab === 'Dashboard') {
                return (
                    <section class="col-span-3 space-y-8">
                        <div class="grid grid-cols-2 gap-4">
                            <div class="bg-white dark:bg-zinc-800 border border-gray-200 dark:border-zinc-700 p-6 rounded-sm shadow-sm">
                                <span class="text-xs uppercase font-bold text-gray-400">Total Equity</span>
                                <div class="text-2xl font-bold font-mono">{formatCurrency(portfolio.equity)}</div>
                            </div>
                            <div class="bg-white dark:bg-zinc-800 border border-gray-200 dark:border-zinc-700 p-6 rounded-sm shadow-sm relative group">
                                <span class="text-xs uppercase font-bold text-gray-400">Available Cash</span>
                                <div class="text-2xl font-bold font-mono">{formatCurrency(portfolio.cash)}</div>
                                <button
                                    onClick={onOpenAddCash}
                                    class="absolute top-4 right-4 bg-emerald-100 dark:bg-emerald-900/30 text-emerald-600 dark:text-emerald-400 p-2 rounded-full hover:bg-emerald-200 dark:hover:bg-emerald-900/50 transition"
                                    title="Add Cash"
                                >
                                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"><line x1="12" y1="5" x2="12" y2="19"></line><line x1="5" y1="12" x2="19" y2="12"></line></svg>
                                </button>
                            </div>
                        </div>
                        <PositionsTable positions={portfolio.positions} onOpenTrade={onOpenTrade} />
                        <MarketTable title="Top Movers" data={marketData.us.slice(0, 3)} loading={loading} onOpenTrade={onOpenTrade} onSelect={onSelectAsset} />
                    </section>
                );
            }

            if (activeTab === 'History') {
                return (
                    <section class="col-span-3 space-y-8">
                        <HistoryTable history={portfolio.history} />
                    </section>
                );
            }

            if (activeTab === 'Settings') {
                return (
                    <section class="col-span-3 space-y-8">
                        <Settings marketData={marketData} />
                    </section>
                );
            }

            if (activeTab === 'Beginner Stats') {
                return (
                    <section class="col-span-3 space-y-8">
                        <BeginnerStats portfolio={portfolio} marketData={marketData} />
                    </section>
                );
            }

            let displayData = [];
            if (activeTab === 'US Markets') displayData = marketData.us;
            if (activeTab === 'Polish Stocks') displayData = marketData.pl;
            if (activeTab === 'Crypto') displayData = marketData.crypto;

            return (
                <section class="col-span-3 space-y-8">
                    {/* Dynamic Chart Area */}
                    <div class="bg-white dark:bg-zinc-800 border border-gray-200 dark:border-zinc-700 p-8 rounded-sm h-96 flex flex-col justify-between shadow-sm">
                        <div class="flex justify-between items-start mb-4">
                            <div>
                                <h2 class="text-2xl font-bold">{currentAsset.symbol}</h2>
                                <span class="font-mono text-gray-500">{currentAsset.name}</span>
                            </div>
                            <div class="text-right">
                                <div class="text-3xl font-mono font-bold">{formatCurrency(currentAsset.price)}</div>
                                <div class={`text-sm font-bold ${currentAsset.change >= 0 ? 'text-emerald-500' : 'text-red-500'}`}>{formatPct(currentAsset.change)}</div>
                            </div>
                        </div>
                        <div class="flex-1 relative w-full h-full">
                            <ChartComponent asset={currentAsset} />
                        </div>
                        <div class="flex gap-4 mt-4">
                            <button onClick={() => onOpenTrade(currentAsset)} class="flex-1 bg-black text-white dark:bg-white dark:text-black py-2 font-bold uppercase rounded-sm hover:opacity-80">Trade {currentAsset.symbol}</button>
                        </div>
                    </div>

                    <div class="bg-white dark:bg-zinc-800 border border-gray-200 dark:border-zinc-700 rounded-sm overflow-hidden shadow-sm">
                        <h2 class="text-2xl font-bold mb-2 px-4 pt-4">{activeTab}</h2>
                        <MarketTable title={`Live ${activeTab} Data`} data={displayData} loading={loading} onOpenTrade={onOpenTrade} onSelect={onSelectAsset} />
                    </div>
                </section>
            );
        };

        // --- Toast Notification Component ---
        const ToastContainer = ({ toasts }) => (
            <div class="fixed bottom-4 right-4 z-50 flex flex-col gap-2 pointer-events-none">
                {toasts.map(t => (
                    <div key={t.id} class={`p-4 rounded-sm shadow-lg border-l-4 text-sm font-bold pointer-events-auto animate-bounce ${t.type === 'error' ? 'bg-white border-red-500 text-red-600' : 'bg-white border-emerald-500 text-emerald-600'} dark:bg-zinc-800 dark:text-gray-100`}>
                        {t.message}
                    </div>
                ))}
            </div>
        );

        const App = () => {
            // Set dark mode default
            const [darkMode, setDarkMode] = useState(() => {
                const saved = localStorage.getItem('theme');
                return saved ? saved === 'dark' : true; // Default to TRUE (Dark)
            });
            const [activeTab, setActiveTab] = useState('Dashboard');
            const [loading, setLoading] = useState(true);
            const [marketData, setMarketData] = useState({ us: [], pl: [], crypto: [] });
            const [selectedAsset, setSelectedAsset] = useState(null);

            const [portfolio, setPortfolio] = useState(() => {
                const saved = localStorage.getItem('portfolio');
                return saved ? JSON.parse(saved) : { cash: 100000, positions: [], history: [], equity: 100000 };
            });
            const [tradeAsset, setTradeAsset] = useState(null);
            const [isAddCashOpen, setIsAddCashOpen] = useState(false);

            // Auto-Trading State
            const [autoTradeEnabled, setAutoTradeEnabled] = useState(false);
            const [config, setConfig] = useState({
                interval: 60, // seconds
                posSizePct: 10, // %
                slPct: 3,
                tpPct: 5
            });
            const [nextTradeTime, setNextTradeTime] = useState(null);
            const [toasts, setToasts] = useState([]);

            const addToast = (message, type = 'info') => {
                const id = Date.now() + Math.random();
                setToasts(prev => [...prev, { id, message, type }]);
                setTimeout(() => setToasts(prev => prev.filter(t => t.id !== id)), 5000);
            };

            // Countdown Timer
            const [timeLeft, setTimeLeft] = useState(0);

            useEffect(() => {
                if (!autoTradeEnabled || !nextTradeTime) {
                    setTimeLeft(0);
                    return;
                }
                const timer = setInterval(() => {
                    const diff = Math.max(0, Math.ceil((nextTradeTime - Date.now()) / 1000));
                    setTimeLeft(diff);
                }, 1000);
                return () => clearInterval(timer);
            }, [autoTradeEnabled, nextTradeTime]);

            const handleAddCash = (amount) => {
                setPortfolio(prev => {
                    const newCash = prev.cash + amount;
                    const newEquity = prev.equity + amount;
                    const newHistory = [...prev.history, {
                        date: new Date(),
                        type: 'DEPOSIT',
                        symbol: 'USD',
                        qty: amount,
                        price: 1,
                        reason: 'Deposit Funds'
                    }];
                    return {
                        ...prev,
                        cash: newCash,
                        equity: newEquity,
                        history: newHistory
                    };
                });
                addToast(`Successfully added ${formatCurrency(amount)}`, 'success');
            };

            // Trade Execution Logic
            const executeTrade = (asset, mode, qty, reason) => {
                // We use a functional update inside the loop, but we need to reference the *current* portfolio state
                // inside the loop. However, inside the interval, 'portfolio' is stale.
                // We will use the functional update form of setPortfolio which is safe.

                setPortfolio(prev => {
                    const price = asset.price;
                    const totalCost = price * qty;

                    if (mode === 'BUY') {
                        if (prev.cash < totalCost) return prev; // Fail silently or log

                        const existing = prev.positions.find(p => p.symbol === asset.symbol);
                        let newPositions;
                        if (existing) {
                            newPositions = prev.positions.map(p => p.symbol === asset.symbol ? { ...p, qty: p.qty + qty, avgPrice: ((p.avgPrice * p.qty) + totalCost) / (p.qty + qty) } : p);
                        } else {
                            newPositions = [...prev.positions, { symbol: asset.symbol, qty, avgPrice: price }];
                        }

                        addToast(`ROBOT: Bought ${asset.symbol} - ${reason}`, 'success');

                        return {
                            ...prev,
                            cash: prev.cash - totalCost,
                            positions: newPositions,
                            history: [...prev.history, { date: new Date(), type: 'BUY', symbol: asset.symbol, qty, price, reason }]
                        };
                    } else {
                        // SELL
                        const existing = prev.positions.find(p => p.symbol === asset.symbol);
                        if (!existing || existing.qty < qty) return prev;

                        let newPositions;
                        if (existing.qty === qty) {
                            newPositions = prev.positions.filter(p => p.symbol !== asset.symbol);
                        } else {
                            newPositions = prev.positions.map(p => p.symbol === asset.symbol ? { ...p, qty: p.qty - qty } : p);
                        }

                        addToast(`ROBOT: Sold ${asset.symbol} - ${reason}`, 'error'); // Red for sell/exit

                        return {
                            ...prev,
                            cash: prev.cash + totalCost,
                            positions: newPositions,
                            history: [...prev.history, { date: new Date(), type: 'SELL', symbol: asset.symbol, qty, price, reason }]
                        };
                    }
                });
            };

            const handleManualTrade = (asset, mode, qty) => {
                executeTrade(asset, mode, qty, "Manual Trade");
                setTradeAsset(null);
            };

            // AUTO TRADING ENGINE
            useEffect(() => {
                if (!autoTradeEnabled || loading) {
                    setNextTradeTime(null);
                    return;
                }

                const runEngine = () => {
                    setPortfolio(currentPortfolio => {
                        // We need to work with a snapshot. 
                        // NOTE: using setPortfolio with callback allows us to access latest state, 
                        // but we can't easily *read* it for decision making inside the same synchronous block unless we check it first.
                        // Actually, we can just do all logic inside the setPortfolio callback? 
                        // No, that's messy. 
                        // Better: The interval passes, we capture values. 
                        // But React state in `setInterval` closure is stale.
                        // We can use a REF to store latest portfolio?
                        return currentPortfolio;
                    });

                    // Ref approach for Portfolio Access
                };

                // Initialize timer
                setNextTradeTime(Date.now() + config.interval * 1000);

                const intervalId = setInterval(() => {
                    // Logic Loop
                    // Access latest portfolio via ref? Or just rely on functional update 2-step?
                    // We need to KNOW current cash to decide to buy.
                    // For this simple app, let's use a "Ref" to hold portfolio for reading in the loop.

                    // Trigger the logic
                    runAutoTrading();
                    setNextTradeTime(Date.now() + config.interval * 1000);

                }, config.interval * 1000);

                return () => clearInterval(intervalId);
            }, [autoTradeEnabled, loading, config.interval]);

            // Ref for Portfolio to be accessible inside setInterval
            const portfolioRef = React.useRef(portfolio);
            useEffect(() => { portfolioRef.current = portfolio; }, [portfolio]);

            const marketDataRef = React.useRef(marketData);
            useEffect(() => { marketDataRef.current = marketData; }, [marketData]);

            const runAutoTrading = () => {
                const currentP = portfolioRef.current;
                const mData = marketDataRef.current;
                const allAssets = [...mData.us, ...mData.pl, ...mData.crypto];

                // 1. AUTO-SELL CHECKS
                currentP.positions.forEach(pos => {
                    const asset = allAssets.find(a => a.symbol === pos.symbol);
                    if (!asset) return;

                    const pnlPct = (asset.price - pos.avgPrice) / pos.avgPrice;
                    const heldDays = 0; // Need tracking of open date. Assume 0 for now or add to pos.

                    // Conditions
                    let sellReason = null;
                    if (pnlPct <= -(config.slPct / 100)) sellReason = `Stop Loss Hit (${(pnlPct * 100).toFixed(2)}%)`;
                    else if (pnlPct >= (config.tpPct / 100)) sellReason = `Take Profit Hit (+${(pnlPct * 100).toFixed(2)}%)`;

                    // Tech Sell
                    const rsi = calcRSI(asset.prices);
                    if (!sellReason && rsi > 75) sellReason = `RSI Overbought (${rsi.toFixed(0)})`;

                    // MACD Death Cross (Current MACD < Signal) - simplified check
                    const macd = calcMACD(asset.prices);
                    if (!sellReason && macd.histogram < 0 && macd.prevMacd > macd.prevSignal) sellReason = "MACD Death Cross";

                    if (sellReason) {
                        executeTrade(asset, 'SELL', pos.qty, sellReason);
                    }
                });

                // 2. AUTO-BUY CHECKS
                // Group by "Tab" or just Type logic?
                // Requirement: "per tab, top 5 positions"
                // Let's simplified: Max 5 positions total per asset class? 
                // Or just Max 5 positions overall for this demo.
                // "fewer than 5 open positions in tab" -> implies we need to know the 'tab' or source of asset.
                // We'll estimate based on symbol logic or just global limit of 15? 
                // Let's do Global Limit of 10 for simplicity or check source list.

                const openPositions = portfolioRef.current.positions; // Fresh ref

                // We need to score ALL assets
                const scored = allAssets.map(a => ({ asset: a, ...calculateScore(a) }));

                // Filter BUY candidates
                const candidates = scored.filter(s => s.score > 60);

                // Sort by Score DESC
                candidates.sort((a, b) => b.score - a.score);

                // Buy Top candidates if Cash > 500
                // Check cash from Ref again (in case sold above) - simplified, just use currentP.cash + potential sales (not accounted for in this tick)
                // We'll just use currentP.cash. 

                let availableCash = currentP.cash;

                // We can't update 'availableCash' easily as executeTrade is async state update.
                // We will limit to 1 Buy per tick to be safe regarding cash sync.
                if (candidates.length > 0 && availableCash > 500) {
                    const best = candidates[0];
                    // Check if already holding?
                    if (!openPositions.find(p => p.symbol === best.asset.symbol)) {
                        // Position Sizing
                        // 10% of Total Portfolio Value
                        const totalEquity = currentP.equity;
                        const sizeAmt = totalEquity * (config.posSizePct / 100);
                        const qty = Math.floor(sizeAmt / best.asset.price);

                        if (qty > 0 && availableCash > (qty * best.asset.price)) {
                            executeTrade(best.asset, 'BUY', qty, `Score: ${best.score} (${best.reasons.join(', ')})`);
                        }
                    }
                }
            };

            // ... savePortfolio effect ...

            useEffect(() => {
                const savePortfolio = () => {
                    let positionValue = 0;
                    // We need to access the LATEST portfolio from state, but this effect runs on 'portfolio' change.
                    // So 'portfolio' here is fresh.
                    const allAssets = [...marketData.us, ...marketData.pl, ...marketData.crypto];
                    if (allAssets.length === 0) return;

                    const newPositions = portfolio.positions.map(p => {
                        const asset = allAssets.find(a => a.symbol === p.symbol);
                        const currentPrice = asset ? asset.price : p.avgPrice;
                        positionValue += p.qty * currentPrice;
                        return { ...p, currentPrice };
                    });

                    const newEquity = portfolio.cash + positionValue;
                    const updated = { ...portfolio, equity: newEquity, positions: newPositions };
                    localStorage.setItem('portfolio', JSON.stringify(updated));
                };
                if (!loading) savePortfolio();
            }, [marketData, portfolio.cash, portfolio.positions.length]); // Dependencies to update equity

            // ... theme effect ...
            useEffect(() => {
                if (darkMode) {
                    document.documentElement.classList.add('dark');
                    localStorage.setItem('theme', 'dark');
                } else {
                    document.documentElement.classList.remove('dark');
                    localStorage.setItem('theme', 'light');
                }
            }, [darkMode]);

            useEffect(() => {
                const loadData = async () => {
                    setLoading(true);
                    const [us, pl, crypto] = await Promise.all([
                        fetchUSStocks(),
                        fetchPLStocks(),
                        fetchCrypto()
                    ]);
                    setMarketData({ us, pl, crypto });
                    setLoading(false);
                };
                loadData();
            }, []);

            return (
                <div class="container mx-auto p-4 max-w-7xl">
                    <div class="fixed top-4 right-4 z-40 flex items-center gap-2">
                        {autoTradeEnabled && (
                            <div class="bg-black text-white px-3 py-2 rounded-sm font-mono text-sm border border-white font-bold">
                                Next: {timeLeft}s
                            </div>
                        )}
                        <button
                            onClick={() => setAutoTradeEnabled(!autoTradeEnabled)}
                            class={`px-4 py-2 font-bold rounded-sm border-2 ${autoTradeEnabled ? 'bg-emerald-500 text-white border-emerald-500 animate-pulse' : 'bg-gray-200 text-gray-500 border-gray-300'}`}
                        >
                            {autoTradeEnabled ? 'STOP ROBOT' : 'START ROBOT'}
                        </button>
                    </div>

                    <div class="mb-4 text-right">
                        <div class="inline-block bg-white dark:bg-zinc-800 p-2 rounded border border-gray-200 dark:border-zinc-700 text-xs shadow-sm">
                            <h4 class="font-bold mb-1">Robot Config</h4>
                            <div class="flex gap-4 items-center">
                                <label class="flex items-center gap-1">
                                    Size:
                                    <input type="range" min="5" max="20" step="1" value={config.posSizePct} onChange={e => setConfig({ ...config, posSizePct: Number(e.target.value) })} />
                                    {config.posSizePct}%
                                </label>
                                <label class="flex items-center gap-1">
                                    Interval:
                                    <select value={config.interval} onChange={e => setConfig({ ...config, interval: Number(e.target.value) })} class="bg-gray-100 dark:bg-zinc-700 p-1">
                                        <option value="10">10s</option>
                                        <option value="30">30s</option>
                                        <option value="60">60s</option>
                                    </select>
                                </label>
                            </div>
                        </div>
                    </div>

                    <Header darkMode={darkMode} toggleTheme={() => setDarkMode(!darkMode)} portfolio={portfolio} />
                    <main class="grid grid-cols-1 md:grid-cols-4 gap-8">
                        <Sidebar activeTab={activeTab} setActiveTab={setActiveTab} />
                        <MainContent
                            activeTab={activeTab}
                            marketData={marketData}
                            loading={loading}
                            portfolio={portfolio}
                            onOpenTrade={setTradeAsset}
                            selectedAsset={selectedAsset}
                            onSelectAsset={setSelectedAsset}
                            onOpenAddCash={() => setIsAddCashOpen(true)}
                        />
                    </main>
                    <TradeModal isOpen={!!tradeAsset} asset={tradeAsset} onClose={() => setTradeAsset(null)} onTrade={handleManualTrade} />
                    <AddCashModal isOpen={isAddCashOpen} onClose={() => setIsAddCashOpen(false)} onAddCash={handleAddCash} />
                    <ToastContainer toasts={toasts} />
                </div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>

</html>