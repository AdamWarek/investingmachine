<!DOCTYPE html>
<html lang="en" class="dark">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Trade.io - Virtual Trading</title>

    <!-- React & ReactDOM -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>

    <!-- Babel for JSX -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            darkMode: 'class',
            theme: {
                extend: {
                    fontFamily: {
                        sans: ['Helvetica', 'Arial', 'sans-serif'],
                        mono: ['ui-monospace', 'SFMono-Regular', 'Menlo', 'Monaco', 'Consolas', "Liberation Mono", "Courier New", 'monospace'],
                    },
                    colors: {
                        swiss: {
                            red: '#ef4444',
                            green: '#10b981',
                            dark: '#18181b',
                            light: '#f4f4f5'
                        }
                    }
                }
            }
        }
    </script>

    <!-- Chart.js -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

    <style>
        body {
            font-family: 'Helvetica', 'Arial', sans-serif;
        }

        .card {
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.05);
        }
    </style>
</head>

<body class="bg-gray-100 dark:bg-zinc-900 text-gray-900 dark:text-gray-100 min-h-screen transition-colors duration-200">
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useMemo } = React;

        // Helper to generate mock history
        // Helper to generate mock history
        // --- Data Generation (Fallback) ---
        const generateHistory = (currentPrice) => {
            const history = [];
            const now = new Date();
            let p = currentPrice;
            const dates = [];
            const prices = [];
            const opens = [];
            const highs = [];
            const lows = [];
            const volumes = [];

            // Generate 60 days of history for indicators (ADX needs valid history)
            for (let i = 0; i <= 60; i++) {
                const date = new Date(now);
                date.setDate(date.getDate() - i);
                dates.unshift(date.toLocaleDateString());

                // Random variation
                const change = (Math.random() - 0.5) * 0.04;
                const open = p;
                const close = p / (1 + change);
                const high = Math.max(open, close) * (1 + Math.random() * 0.01);
                const low = Math.min(open, close) * (1 - Math.random() * 0.01);
                const volume = Math.floor(Math.random() * 1000000) + 500000;

                prices.unshift(close);
                opens.unshift(open);
                highs.unshift(high);
                lows.unshift(low);
                volumes.unshift(volume);

                p = close; // walk back
            }

            // Re-align to current price being the last one
            prices[prices.length - 1] = currentPrice;

            return { dates, prices, opens, highs, lows, volumes };
        };

        // (Client-side fetchers moved to server.js)

        // --- Mock Data & Utilities ---
        const formatCurrency = (val) => new Intl.NumberFormat('en-US', { style: 'currency', currency: 'USD' }).format(val);
        const formatPct = (val) => (val > 0 ? '+' : '') + val.toFixed(2) + '%';

        // --- API & Data Logic ---

        // --- Technical Indicators ---

        const calcSMA = (data, period) => {
            if (data.length < period) return null;
            const sum = data.slice(data.length - period).reduce((a, b) => a + b, 0);
            return sum / period;
        };

        const calcStdDev = (data, period, sma) => {
            if (data.length < period) return 0;
            const slice = data.slice(data.length - period);
            const mean = sma || calcSMA(data, period);
            const sqDiffs = slice.map(v => Math.pow(v - mean, 2));
            const avgSqDiff = sqDiffs.reduce((a, b) => a + b, 0) / period;
            return Math.sqrt(avgSqDiff);
        };

        const calcBollingerBands = (prices, period = 20, multiplier = 2) => {
            const sma = calcSMA(prices, period);
            if (!sma) return null;
            const stdDev = calcStdDev(prices, period, sma);
            return {
                middle: sma,
                upper: sma + (stdDev * multiplier),
                lower: sma - (stdDev * multiplier)
            };
        };

        const calcEMA = (prices, period) => {
            if (prices.length < period) return null;
            const k = 2 / (period + 1);
            // Start with SMA for first EMA
            let ema = prices.slice(0, period).reduce((a, b) => a + b, 0) / period;
            for (let i = period; i < prices.length; i++) {
                ema = (prices[i] * k) + (ema * (1 - k));
            }
            return ema;
        };

        const calcRSI = (closes, period = 14) => {
            if (closes.length < period + 1) return 50;
            let gains = 0, losses = 0;
            // First average
            for (let i = 1; i <= period; i++) {
                const change = closes[i] - closes[i - 1];
                if (change > 0) gains += change;
                else losses -= change;
            }
            let avgGain = gains / period;
            let avgLoss = losses / period;

            // Smoothed
            for (let i = period + 1; i < closes.length; i++) {
                const change = closes[i] - closes[i - 1];
                const gain = change > 0 ? change : 0;
                const loss = change < 0 ? -change : 0;
                avgGain = (avgGain * (period - 1) + gain) / period;
                avgLoss = (avgLoss * (period - 1) + loss) / period;
            }

            if (avgLoss === 0) return 100;
            const rs = avgGain / avgLoss;
            return 100 - (100 / (1 + rs));
        };

        const calcMACD = (closes) => {
            if (closes.length < 26) return { macd: 0, signal: 0, histogram: 0 };

            const ema12 = [];
            const ema26 = [];
            const macdLine = [];

            // Calculate EMA12 series
            let k12 = 2 / (12 + 1);
            let e12 = closes.slice(0, 12).reduce((a, b) => a + b, 0) / 12;
            for (let i = 12; i < closes.length; i++) {
                e12 = (closes[i] * k12) + (e12 * (1 - k12));
                ema12[i] = e12;
            }

            // Calculate EMA26 series
            let k26 = 2 / (26 + 1);
            let e26 = closes.slice(0, 26).reduce((a, b) => a + b, 0) / 26;
            for (let i = 26; i < closes.length; i++) {
                e26 = (closes[i] * k26) + (e26 * (1 - k26));
                ema26[i] = e26;
            }

            // MACD Line = EMA12 - EMA26
            for (let i = 26; i < closes.length; i++) {
                macdLine.push((ema12[i] || 0) - (ema26[i] || 0));
            }

            // Signal Line = EMA9 of MACD Line
            if (macdLine.length < 9) return { macd: 0, signal: 0, histogram: 0 };

            const k9 = 2 / (9 + 1);
            let signal = macdLine.slice(0, 9).reduce((a, b) => a + b, 0) / 9;
            for (let i = 9; i < macdLine.length; i++) {
                signal = (macdLine[i] * k9) + (signal * (1 - k9));
            }

            const currentMacd = macdLine[macdLine.length - 1];
            return {
                macd: currentMacd,
                signal: signal,
                histogram: currentMacd - signal,
                // Approximation for trend
                prevMacd: macdLine[macdLine.length - 2],
                prevSignal: signal // Ideally this should be prev signal
            };
        };

        const calcADX = (highs, lows, closes, period = 14) => {
            if (highs.length < period * 2) return 20; // Default if not enough data

            const trs = [];
            const dmPlus = [];
            const dmMinus = [];

            for (let i = 1; i < highs.length; i++) {
                const up = highs[i] - highs[i - 1];
                const down = lows[i - 1] - lows[i];

                dmPlus.push((up > down && up > 0) ? up : 0);
                dmMinus.push((down > up && down > 0) ? down : 0);

                const tr = Math.max(
                    highs[i] - lows[i],
                    Math.abs(highs[i] - closes[i - 1]),
                    Math.abs(lows[i] - closes[i - 1])
                );
                trs.push(tr);
            }

            // Smoothed
            let smTR = trs.slice(0, period).reduce((a, b) => a + b, 0);
            let smDMPlus = dmPlus.slice(0, period).reduce((a, b) => a + b, 0);
            let smDMMinus = dmMinus.slice(0, period).reduce((a, b) => a + b, 0);

            const dxs = [];

            for (let i = period; i < trs.length; i++) {
                smTR = smTR - (smTR / period) + trs[i];
                smDMPlus = smDMPlus - (smDMPlus / period) + dmPlus[i];
                smDMMinus = smDMMinus - (smDMMinus / period) + dmMinus[i];

                const diPlus = smTR === 0 ? 0 : (smDMPlus / smTR) * 100;
                const diMinus = smTR === 0 ? 0 : (smDMMinus / smTR) * 100;

                const sumDi = diPlus + diMinus;
                const dx = sumDi === 0 ? 0 : (Math.abs(diPlus - diMinus) / sumDi) * 100;
                dxs.push(dx);
            }

            // ADX is EMA of DX
            if (dxs.length < period) return dxs[dxs.length - 1] || 20;

            let adx = dxs.slice(0, period).reduce((a, b) => a + b, 0) / period;
            for (let i = period; i < dxs.length; i++) {
                adx = ((adx * (period - 1)) + dxs[i]) / period;
            }

            return adx;
        };

        // --- Scoring Logic ---
        const calculateScore = (asset) => {
            const prices = asset.prices;
            const volumes = asset.volumes;
            const highs = asset.highs;
            const lows = asset.lows;
            const opens = asset.opens;

            if (!prices || prices.length < 30) return { score: 0, reasons: [] };

            let score = 0;
            const reasons = [];

            // 1. RSI (14)
            const rsi = calcRSI(prices, 14);
            if (rsi >= 40 && rsi <= 60) {
                score += 20;
                reasons.push("RSI Neutral (40-60)");
            } else if (rsi < 30) {
                score += 20;
                reasons.push("RSI Oversold (<30)");
            } else if (rsi > 75) {
                score -= 15;
                reasons.push("RSI Overbought (>75)");
            }

            // 2. MACD Signal Cross (Last 3 candles)
            const macdData = calcMACD(prices);
            if (macdData.histogram > 0) {
                score += 20;
                reasons.push("MACD Bullish");
            }

            // 3. Volume Spike
            const currentVol = volumes[volumes.length - 1];
            const avgVol = volumes.slice(Math.max(0, volumes.length - 21), volumes.length - 1).reduce((a, b) => a + b, 0) / 20;
            if (currentVol > 1.5 * avgVol) {
                score += 15;
                reasons.push("Volume Spike (>1.5x Avg)");
            }

            // 4. Bollinger Bands
            const bb = calcBollingerBands(prices, 20, 2);
            const currentPrice = prices[prices.length - 1];
            if (bb) {
                if (currentPrice <= bb.lower * 1.02) {
                    score += 15;
                    reasons.push("Near Lower BB (Dip)");
                } else if (currentPrice >= bb.upper * 0.98) {
                    score -= 10;
                    reasons.push("Near Upper BB");
                }
            }

            // 5. Price vs EMA(20)
            const ema20 = calcEMA(prices, 20);
            if (ema20 && currentPrice > ema20) {
                score += 10;
                reasons.push("Price > EMA(20)");
            }

            // 6. ADX Trend Strength
            const adx = calcADX(highs, lows, prices, 14);
            if (adx > 25) {
                score += 10;
                reasons.push(`ADX Strong Trend (${adx.toFixed(1)})`);
            }

            return { score: Math.max(0, Math.min(100, score)), reasons };
        };

        // --- Components ---

        const TradeModal = ({ isOpen, onClose, asset, onTrade }) => {
            if (!isOpen || !asset) return null;
            const [qty, setQty] = useState(1);
            const [mode, setMode] = useState('BUY'); // BUY or SELL

            const total = qty * asset.price;

            return (
                <div class="fixed inset-0 bg-black/50 flex items-center justify-center p-4 z-50">
                    <div class="bg-white dark:bg-zinc-900 border border-black dark:border-white p-6 max-w-sm w-full shadow-2xl rounded-sm">
                        <h2 class="text-xl font-bold mb-4 uppercase">{mode} {asset.symbol}</h2>

                        <div class="flex gap-2 mb-4">
                            <button onClick={() => setMode('BUY')} class={`flex-1 py-2 font-bold ${mode === 'BUY' ? 'bg-black text-white dark:bg-white dark:text-black' : 'bg-gray-200 text-gray-500'}`}>BUY</button>
                            <button onClick={() => setMode('SELL')} class={`flex-1 py-2 font-bold ${mode === 'SELL' ? 'bg-black text-white dark:bg-white dark:text-black' : 'bg-gray-200 text-gray-500'}`}>SELL</button>
                        </div>

                        <div class="space-y-4 font-mono text-sm">
                            <div class="flex justify-between">
                                <span>Price:</span>
                                <span>{formatCurrency(asset.price)}</span>
                            </div>
                            <div class="flex justify-between items-center">
                                <span>Quantity:</span>
                                <input type="number" min="1" value={qty} onChange={e => setQty(Number(e.target.value))} class="w-20 p-1 border border-gray-300 dark:border-zinc-700 bg-transparent text-right" />
                            </div>
                            <div class="flex justify-between border-t border-gray-300 dark:border-zinc-700 pt-2 font-bold">
                                <span>Total:</span>
                                <span>{formatCurrency(total)}</span>
                            </div>
                        </div>

                        <div class="mt-6 flex gap-2">
                            <button onClick={onClose} class="flex-1 py-2 border border-gray-300 dark:border-zinc-700 font-bold hover:bg-gray-100 dark:hover:bg-zinc-800">CANCEL</button>
                            <button onClick={() => onTrade(asset, mode, qty)} class="flex-1 py-2 bg-emerald-500 text-white font-bold hover:bg-emerald-600">CONFIRM</button>
                        </div>
                    </div>
                </div>
            );
        };

        const Header = ({ darkMode, toggleTheme, portfolio, liveEquity, appVersion }) => (
            <header class="flex justify-between items-end mb-8 border-b-2 border-black dark:border-white pb-4 px-8 pt-6">
                <div>
                    <h1 class="text-4xl font-extrabold tracking-tighter uppercase dark:text-white flex items-center gap-2">
                        Trade<span class="text-gray-400">.io</span>
                        {appVersion && (
                            <span class="text-[10px] bg-gray-200 dark:bg-zinc-800 text-gray-500 dark:text-gray-400 px-2 py-1 rounded-sm font-mono tracking-normal leading-none self-start mt-2 border border-gray-300 dark:border-zinc-700">
                                v.{appVersion}
                            </span>
                        )}
                    </h1>
                    <p class="text-sm text-gray-500 dark:text-gray-400 mt-1">Professional Trading Environment</p>
                </div>
                <div class="flex items-end gap-8">
                    <div class="text-right">
                        <div class="text-xs uppercase font-bold text-gray-400 tracking-widest mb-1">Total Equity</div>
                        <div class="text-3xl font-bold font-mono tracking-tight">{formatCurrency(liveEquity !== undefined ? liveEquity : portfolio.equity)}</div>
                        <div class="text-sm font-medium mt-1 flex items-center justify-end gap-1 font-mono">
                            <span class="text-gray-500">Cash: {formatCurrency(portfolio.cash)}</span>
                        </div>
                    </div>
                    <button onClick={toggleTheme} class="p-2 rounded-full hover:bg-gray-200 dark:hover:bg-zinc-800 transition">
                        {darkMode ? '‚òÄÔ∏è' : 'üåô'}
                    </button>
                </div>
            </header>
        );

        const Sidebar = ({ activeTab, setActiveTab }) => (
            <aside class="col-span-1 space-y-6">
                <nav class="space-y-1">
                    {['Dashboard', 'Beginner Stats', 'US Markets', 'Polish Stocks', 'Crypto', 'History', 'Settings'].map(tab => (
                        <button
                            key={tab}
                            onClick={() => setActiveTab(tab)}
                            class={`w-full text-left block px-4 py-3 font-bold rounded-sm transition ${activeTab === tab
                                ? 'bg-black dark:bg-white text-white dark:text-black'
                                : 'hover:bg-gray-200 dark:hover:bg-zinc-800'
                                }`}
                        >
                            {tab}
                        </button>
                    ))}
                </nav>
            </aside>
        );

        const ChartComponent = ({ asset }) => {
            const canvasRef = React.useRef(null);
            const chartRef = React.useRef(null);
            const [timeframe, setTimeframe] = useState('1D');
            const [chartData, setChartData] = useState(null);
            const [isLoading, setIsLoading] = useState(false);

            const timeframes = [
                { label: '1D', range: '1d', interval: '5m' },
                { label: '1W', range: '5d', interval: '15m' },
                { label: '1M', range: '1mo', interval: '1d' },
                { label: '3M', range: '3mo', interval: '1d' },
                { label: '1Y', range: '1y', interval: '1wk' },
                { label: 'ALL', range: 'max', interval: '1mo' }
            ];

            React.useEffect(() => {
                let isMounted = true;
                const fetchData = async () => {
                    if (!asset) return;
                    setIsLoading(true);
                    try {
                        const tf = timeframes.find(t => t.label === timeframe) || timeframes[0];
                        const res = await fetch(`/api/history/${asset.symbol}?range=${tf.range}&interval=${tf.interval}`);
                        if (res.ok) {
                            const data = await res.json();
                            if (isMounted) setChartData({ dates: data.dates, prices: data.prices });
                        } else {
                            if (isMounted) setChartData({ dates: asset.dates, prices: asset.prices });
                        }
                    } catch (e) {
                        if (isMounted) setChartData({ dates: asset.dates, prices: asset.prices });
                    } finally {
                        if (isMounted) setIsLoading(false);
                    }
                };
                fetchData();
                return () => { isMounted = false; };
            }, [asset, timeframe]);

            React.useEffect(() => {
                if (!canvasRef.current || !asset) return;

                const ctx = canvasRef.current.getContext('2d');

                if (chartRef.current) {
                    chartRef.current.destroy();
                }

                let labels = [];
                let dataPoints = [];

                if (chartData && chartData.dates && chartData.prices && chartData.dates.length > 0) {
                    labels = chartData.dates;
                    dataPoints = chartData.prices;
                } else if (asset.dates && asset.prices && asset.dates.length > 0) {
                    // Fallback to loaded asset history if chartData is empty or fails
                    labels = asset.dates;
                    dataPoints = asset.prices;
                } else {
                    // General offline fallback generating mock history 
                    let price = asset.price;
                    const now = new Date();
                    for (let i = 30; i >= 0; i--) {
                        const date = new Date(now);
                        date.setDate(date.getDate() - i);
                        price = price * (1 + (Math.random() - 0.5) * 0.05);
                        labels.push(date.toLocaleDateString());
                        dataPoints.push(price);
                    }
                    dataPoints[dataPoints.length - 1] = asset.price;
                }

                chartRef.current = new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels: labels,
                        datasets: [{
                            label: 'Price (USD)',
                            data: dataPoints,
                            borderColor: asset.change >= 0 ? '#10b981' : '#ef4444',
                            backgroundColor: (context) => {
                                const ctx = context.chart.ctx;
                                const gradient = ctx.createLinearGradient(0, 0, 0, 300);
                                gradient.addColorStop(0, asset.change >= 0 ? 'rgba(16, 185, 129, 0.2)' : 'rgba(239, 68, 68, 0.2)');
                                gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
                                return gradient;
                            },
                            borderWidth: 2,
                            fill: true,
                            tension: 0.4,
                            pointRadius: 0
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: { display: false },
                            tooltip: {
                                mode: 'index',
                                intersect: false,
                                callbacks: { label: (ctx) => formatCurrency(ctx.raw) }
                            }
                        },
                        scales: {
                            x: { display: false },
                            y: {
                                display: true,
                                position: 'right',
                                grid: { color: '#33333333' }
                            }
                        },
                        interaction: {
                            mode: 'nearest',
                            axis: 'x',
                            intersect: false
                        }
                    }
                });

                return () => {
                    if (chartRef.current) chartRef.current.destroy();
                };
            }, [asset, chartData]); // Re-render when asset or chartData changes

            return (
                <div class="w-full h-full flex flex-col relative group">
                    <div class="absolute top-2 right-2 z-10 flex gap-1 bg-white/50 dark:bg-black/50 p-1 rounded backdrop-blur border border-gray-200 dark:border-zinc-700 shadow-sm opacity-0 group-hover:opacity-100 transition-opacity">
                        {timeframes.map(tf => (
                            <button
                                key={tf.label}
                                onClick={() => setTimeframe(tf.label)}
                                class={`px-2 py-1 text-[10px] font-bold rounded transition ${timeframe === tf.label ? 'bg-black text-white dark:bg-white dark:text-black shadow' : 'text-gray-500 hover:bg-gray-200 dark:hover:bg-zinc-700 hover:text-gray-900 dark:hover:text-gray-100'}`}
                            >
                                {tf.label}
                            </button>
                        ))}
                    </div>
                    {isLoading && (
                        <div class="absolute inset-0 flex items-center justify-center bg-white/20 dark:bg-black/20 z-20 backdrop-blur-[1px] rounded-sm">
                            <span class="animate-pulse font-bold text-xs uppercase tracking-widest bg-white dark:bg-zinc-900 px-4 py-2 rounded shadow border border-gray-200 dark:border-zinc-700">Loading...</span>
                        </div>
                    )}
                    <div class="flex-1 relative w-full h-full mt-2 pb-2">
                        <canvas ref={canvasRef} />
                    </div>
                </div>
            );
        };

        const MarketTable = ({ title, data, loading, onOpenTrade, onSelect }) => (
            <div class="bg-white dark:bg-zinc-800 border border-gray-200 dark:border-zinc-700 rounded-sm overflow-hidden shadow-sm">
                <div class="p-4 border-b border-gray-200 dark:border-zinc-700 font-bold uppercase tracking-wider text-sm">{title}</div>
                <table class="w-full text-left">
                    <thead class="bg-gray-50 dark:bg-zinc-900 border-b border-gray-200 dark:border-zinc-700">
                        <tr class="text-xs font-bold text-gray-500 uppercase tracking-wider">
                            <th class="px-6 py-4">Instrument</th>
                            <th class="px-6 py-4">Price</th>
                            <th class="px-6 py-4">Change</th>
                            <th class="px-6 py-4 text-right">Action</th>
                        </tr>
                    </thead>
                    <tbody class="divide-y divide-gray-100 dark:divide-zinc-700 font-mono text-sm">
                        {loading ? (
                            <tr><td colSpan="4" class="p-6 text-center text-gray-500">Loading market data...</td></tr>
                        ) : data.map((item, idx) => (
                            <tr key={idx} onClick={() => onSelect && onSelect(item)} class="hover:bg-gray-50 dark:hover:bg-zinc-700/50 transition cursor-pointer">
                                <td class="px-6 py-4 font-bold text-sans">
                                    <div class="font-bold">{item.symbol}</div>
                                    <div class="text-xs text-gray-500 dark:text-gray-400 font-sans">{item.name}</div>
                                </td>
                                <td class="px-6 py-4">{formatCurrency(item.price)}</td>
                                <td class={`px-6 py-4 ${item.change >= 0 ? 'text-emerald-500' : 'text-red-500'}`}>
                                    {formatPct(item.change)}
                                </td>
                                <td class="px-6 py-4 text-right">
                                    <button onClick={(e) => { e.stopPropagation(); onOpenTrade(item); }} class="bg-black dark:bg-white text-white dark:text-black hover:opacity-80 px-4 py-1 rounded-sm text-xs font-bold uppercase">Trade</button>
                                </td>
                            </tr>
                        ))}
                    </tbody>
                </table>
            </div>
        );

        const PositionsTable = ({ positions, marketData, onOpenTrade }) => {
            const allAssets = marketData ? [...(marketData.us || []), ...(marketData.pl || []), ...(marketData.crypto || [])] : [];
            return (
                <div class="bg-white dark:bg-zinc-800 border border-gray-200 dark:border-zinc-700 rounded-sm overflow-hidden shadow-sm">
                    <div class="p-4 border-b border-gray-200 dark:border-zinc-700 font-bold uppercase tracking-wider text-sm">Active Positions</div>
                    {positions.length === 0 ? (
                        <div class="p-8 text-center text-gray-500">No active positions</div>
                    ) : (
                        <table class="w-full text-left">
                            <thead class="bg-gray-50 dark:bg-zinc-900 border-b border-gray-200 dark:border-zinc-700">
                                <tr class="text-xs font-bold text-gray-500 uppercase tracking-wider">
                                    <th class="px-6 py-4">Instrument</th>
                                    <th class="px-6 py-4">Qty</th>
                                    <th class="px-6 py-4">Avg Buy</th>
                                    <th class="px-6 py-4">Current</th>
                                    <th class="px-6 py-4 text-right">Value</th>
                                    <th class="px-6 py-4 text-right">P/L</th>
                                    <th class="px-6 py-4 text-right">Action</th>
                                </tr>
                            </thead>
                            <tbody class="divide-y divide-gray-100 dark:divide-zinc-700 font-mono text-sm">
                                {positions.map((pos, idx) => {
                                    const asset = allAssets.find(a => a.symbol === pos.symbol);
                                    const currentPrice = asset ? asset.price : (pos.currentPrice || pos.avgPrice);
                                    const pl = (currentPrice - pos.avgPrice) * pos.qty;
                                    const plPct = pos.avgPrice > 0 ? ((currentPrice - pos.avgPrice) / pos.avgPrice) * 100 : 0;
                                    return (
                                        <tr key={idx} class="hover:bg-gray-50 dark:hover:bg-zinc-700/50 transition">
                                            <td class="px-6 py-4 font-bold text-sans">{pos.symbol}</td>
                                            <td class="px-6 py-4">{pos.qty}</td>
                                            <td class="px-6 py-4">{formatCurrency(pos.avgPrice)}</td>
                                            <td class="px-6 py-4">{formatCurrency(currentPrice)}</td>
                                            <td class="px-6 py-4 text-right font-bold">{formatCurrency(pos.qty * currentPrice)}</td>
                                            <td class={`px-6 py-4 text-right font-bold ${pl >= 0 ? 'text-emerald-500' : 'text-red-500'}`}>
                                                {pl >= 0 ? '+' : ''}{formatCurrency(pl)}<br />
                                                <span class="text-xs opacity-80">{pl >= 0 ? '+' : ''}{plPct.toFixed(2)}%</span>
                                            </td>
                                            <td class="px-6 py-4 text-right">
                                                <button onClick={() => onOpenTrade({ symbol: pos.symbol, price: currentPrice })} class="bg-black dark:bg-white text-white dark:text-black hover:opacity-80 px-4 py-1 rounded-sm text-xs font-bold uppercase">Trade</button>
                                            </td>
                                        </tr>
                                    )
                                })}
                            </tbody>
                        </table>
                    )}
                </div>
            );
        };

        const HistoryTable = ({ history }) => (
            <div class="bg-white dark:bg-zinc-800 border border-gray-200 dark:border-zinc-700 rounded-sm overflow-hidden shadow-sm">
                <div class="p-4 border-b border-gray-200 dark:border-zinc-700 font-bold uppercase tracking-wider text-sm">Transaction History</div>
                {history.length === 0 ? (
                    <div class="p-8 text-center text-gray-500">No transactions yet</div>
                ) : (
                    <div class="overflow-x-auto">
                        <table class="w-full text-left">
                            <thead class="bg-gray-50 dark:bg-zinc-900 border-b border-gray-200 dark:border-zinc-700">
                                <tr class="text-xs font-bold text-gray-500 uppercase tracking-wider">
                                    <th class="px-6 py-4">Date</th>
                                    <th class="px-6 py-4">Type</th>
                                    <th class="px-6 py-4">Instrument</th>
                                    <th class="px-6 py-4">Qty</th>
                                    <th class="px-6 py-4 text-right">Price</th>
                                    <th class="px-6 py-4 text-right">Total</th>
                                    <th class="px-6 py-4">Reason</th>
                                </tr>
                            </thead>
                            <tbody class="divide-y divide-gray-100 dark:divide-zinc-700 font-mono text-sm">
                                {history.slice().reverse().map((tx, idx) => (
                                    <tr key={idx} class="hover:bg-gray-50 dark:hover:bg-zinc-700/50 transition">
                                        <td class="px-6 py-4 text-xs text-gray-500">{new Date(tx.date).toLocaleString()}</td>
                                        <td class={`px-6 py-4 font-bold ${tx.type === 'BUY' ? 'text-emerald-500' : 'text-red-500'}`}>{tx.type}</td>
                                        <td class="px-6 py-4 font-bold">{tx.symbol}</td>
                                        <td class="px-6 py-4">{tx.qty}</td>
                                        <td class="px-6 py-4 text-right">{formatCurrency(tx.price)}</td>
                                        <td class="px-6 py-4 text-right font-bold">{formatCurrency(tx.qty * tx.price)}</td>
                                        <td class="px-6 py-4 text-xs max-w-xs truncate" title={tx.reason}>{tx.reason}</td>
                                    </tr>
                                ))}
                            </tbody>
                        </table>
                    </div>
                )}
            </div>
        );

        const Settings = ({ marketData, config, updateConfig }) => {
            const getStatusColor = (data) => data && data.length > 0 ? 'bg-emerald-500' : 'bg-red-500';
            const [botLogs, setBotLogs] = useState([]);

            // Poll bot logs only when Settings tab is active
            useEffect(() => {
                const fetchLogs = () => {
                    fetch('/api/bot/logs')
                        .then(res => res.json())
                        .then(data => {
                            if (data && Array.isArray(data)) {
                                setBotLogs(data);
                            }
                        })
                        .catch(err => console.error("Failed to load bot logs:", err));
                };

                fetchLogs(); // Initial
                const logIntervalId = setInterval(fetchLogs, 3000); // Every 3s
                return () => clearInterval(logIntervalId);
            }, []);

            return (
                <div class="grid grid-cols-1 lg:grid-cols-2 gap-8">
                    <div class="bg-white dark:bg-zinc-800 border border-gray-200 dark:border-zinc-700 rounded-sm p-6 max-w-lg">
                        <h2 class="text-xl font-bold mb-4 uppercase">Settings</h2>
                        <div class="space-y-4">

                            <div class="mb-4">
                                <h3 class="text-sm font-bold mb-2">Robot Config</h3>
                                <div class="flex gap-4 items-center text-xs font-mono">
                                    <label class="flex items-center gap-1">
                                        Interval:
                                        <select value={config.interval} onChange={e => updateConfig({ ...config, interval: Number(e.target.value) })} class="bg-gray-100 dark:bg-zinc-700 p-1">
                                            <option value="10">10s</option>
                                            <option value="30">30s</option>
                                            <option value="60">60s</option>
                                        </select>
                                    </label>
                                </div>
                            </div>

                            <div class="pt-6 border-t border-gray-200 dark:border-zinc-700">
                                <h3 class="text-sm font-bold mb-2">API Status</h3>
                                <ul class="text-xs space-y-2 text-gray-500 font-mono">
                                    <li class="flex items-center gap-2">
                                        <span class={`w-3 h-3 rounded-full ${marketData?.crypto?.length > 0 ? 'bg-emerald-500' : 'bg-red-500'}`}></span>
                                        Crypto: CoinGecko (Public API)
                                    </li>
                                    <li class="flex items-center gap-2">
                                        <span class={`w-3 h-3 rounded-full ${marketData?.us?.length > 0 ? 'bg-emerald-500' : 'bg-red-500'}`}></span>
                                        US Stocks: Yahoo Finance via Proxy
                                    </li>
                                    <li class="flex items-center gap-2">
                                        <span class={`w-3 h-3 rounded-full ${marketData?.pl?.length > 0 ? 'bg-emerald-500' : 'bg-red-500'}`}></span>
                                        PL Stocks: Yahoo Finance via Proxy
                                    </li>
                                </ul>
                            </div>
                        </div>
                    </div>

                    {/* Live Terminal UI */}
                    <div class="bg-black border border-zinc-700 rounded-sm p-4 overflow-hidden flex flex-col h-[400px] shadow-lg">
                        <div class="flex justify-between items-center mb-2 pb-2 border-b border-zinc-800">
                            <div class="flex items-center gap-2">
                                <span class="text-xs text-gray-400 font-mono uppercase tracking-widest font-bold">Terminal / Live View</span>
                            </div>
                            <div class="flex gap-1">
                                <div class="w-3 h-3 rounded-full bg-red-500 opacity-50"></div>
                                <div class="w-3 h-3 rounded-full bg-yellow-500 opacity-50"></div>
                                <div class="w-3 h-3 rounded-full bg-emerald-500"></div>
                            </div>
                        </div>
                        <div class="flex-1 overflow-y-auto font-mono text-xs text-emerald-400 space-y-1 pr-2 custom-scrollbar flex flex-col-reverse">
                            {botLogs.length === 0 ? (
                                <div class="text-gray-600 italic">No logs captured yet. Turn on the robot and wait for the first cycle...</div>
                            ) : (
                                // Render logs backwards (newest at bottom by default due to flex-col-reverse, so we reverse the array to keep newest at bottom )
                                [...botLogs].reverse().map((log, idx) => (
                                    <div key={idx} class="break-words">
                                        <span class="text-gray-500 mr-2">[{new Date(log.time).toLocaleTimeString()}]</span>
                                        {log.msg}
                                    </div>
                                ))
                            )}
                        </div>
                    </div>
                </div>
            );
        };

        const BeginnerStats = ({ portfolio, marketData }) => {
            // Aggregate data
            const stats = useMemo(() => {
                const uniqueSymbols = new Set([
                    ...portfolio.history.map(h => h.symbol),
                    ...portfolio.positions.map(p => p.symbol)
                ]);

                // Exclude 'USD' (Cash deposits)
                uniqueSymbols.delete('USD');

                const computed = [];
                const allMarketAssets = [...(marketData.us || []), ...(marketData.pl || []), ...(marketData.crypto || [])];

                uniqueSymbols.forEach(symbol => {
                    // Filter history for this symbol
                    const txs = portfolio.history.filter(h => h.symbol === symbol);

                    let totalInvested = 0;
                    let totalSold = 0;
                    let totalQtyBuys = 0;

                    txs.forEach(tx => {
                        if (tx.type === 'BUY') {
                            totalInvested += tx.qty * tx.price;
                            totalQtyBuys += tx.qty;
                        } else if (tx.type === 'SELL') {
                            totalSold += tx.qty * tx.price;
                        }
                    });

                    // Current Position Value
                    const pos = portfolio.positions.find(p => p.symbol === symbol);
                    // Get real-time price if available, else use pos.avgPrice or last known
                    const marketAsset = allMarketAssets.find(a => a.symbol === symbol);
                    const currentPrice = marketAsset ? marketAsset.price : (pos ? pos.avgPrice : 0);

                    const openQty = pos ? pos.qty : 0;
                    const currentValue = openQty * currentPrice;

                    // Total P/L = (Returned + CurrentValue) - Invested
                    const totalPL = (totalSold + currentValue) - totalInvested;
                    const isProfitable = totalPL >= 0;

                    computed.push({
                        symbol,
                        name: marketAsset ? marketAsset.name : symbol,
                        totalInvested,
                        totalSold,
                        currentValue,
                        totalPL,
                        isProfitable,
                        openQty
                    });
                });

                return computed.sort((a, b) => b.totalPL - a.totalPL); // Best first
            }, [portfolio, marketData]);

            return (
                <div class="space-y-6">
                    <div class="bg-gradient-to-r from-indigo-500 to-purple-600 p-8 rounded-lg text-white shadow-lg mb-8">
                        <h2 class="text-3xl font-bold mb-2">Your Investing Journey</h2>
                        <p class="opacity-90">Keep track of your total profits and losses for each asset. Green means you made money, Red means you lost money.</p>
                    </div>

                    <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
                        {stats.map(stat => (
                            <div key={stat.symbol} class="bg-white dark:bg-zinc-800 border-2 rounded-xl p-6 shadow-sm hover:shadow-md transition relative overflow-hidden group">
                                <div class={`absolute top-0 left-0 w-2 h-full ${stat.isProfitable ? 'bg-emerald-500' : 'bg-red-500'}`}></div>

                                <div class="flex justify-between items-start mb-4 pl-4">
                                    <div>
                                        <h3 class="text-2xl font-bold">{stat.symbol}</h3>
                                        <p class="text-xs text-gray-500 font-bold uppercase">{stat.name}</p>
                                    </div>
                                    <div class={`text-xs font-bold px-2 py-1 rounded ${stat.openQty > 0 ? 'bg-blue-100 text-blue-700' : 'bg-gray-100 text-gray-500'}`}>
                                        {stat.openQty > 0 ? 'ACTIVE' : 'CLOSED'}
                                    </div>
                                </div>

                                <div class="pl-4 space-y-4">
                                    <div>
                                        <p class="text-xs font-bold text-gray-400 uppercase tracking-wider">Total Profit / Loss</p>
                                        <p class={`text-3xl font-bold font-mono ${stat.isProfitable ? 'text-emerald-500' : 'text-red-500'}`}>
                                            {stat.totalPL >= 0 ? '+' : ''}{formatCurrency(stat.totalPL)}
                                        </p>
                                    </div>

                                    <div class="grid grid-cols-2 gap-4 text-sm pt-4 border-t border-gray-100 dark:border-zinc-700">
                                        <div>
                                            <p class="text-xs text-gray-400">Total Invested</p>
                                            <p class="font-bold">{formatCurrency(stat.totalInvested)}</p>
                                        </div>
                                        <div>
                                            <p class="text-xs text-gray-400">Current Value</p>
                                            <p class="font-bold">{formatCurrency(stat.currentValue + stat.totalSold)} <span class="text-[10px] opacity-60">(Inc. Sold)</span></p>
                                        </div>
                                    </div>

                                    <div class={`p-3 rounded text-sm font-bold text-center ${stat.isProfitable ? 'bg-emerald-50 text-emerald-700 dark:bg-emerald-900/20 dark:text-emerald-400' : 'bg-red-50 text-red-700 dark:bg-red-900/20 dark:text-red-400'}`}>
                                        {stat.isProfitable
                                            ? "üéâ Great job! You are in profit."
                                            : "üìâ Currently down. Persistence is key!"}
                                    </div>
                                </div>
                            </div>
                        ))}
                    </div>
                    {stats.length === 0 && (
                        <div class="text-center p-12 bg-gray-50 dark:bg-zinc-800/50 rounded-lg dashed-border">
                            <h3 class="text-xl font-bold text-gray-400">No trading history yet</h3>
                            <p class="text-gray-500 mt-2">Make your first trade to see statistics here!</p>
                        </div>
                    )}
                </div>
            );
        };

        const AddCashModal = ({ isOpen, onClose, onAddCash }) => {
            if (!isOpen) return null;
            const [amount, setAmount] = useState('');

            const handleSubmit = (e) => {
                e.preventDefault();
                const val = parseFloat(amount);
                if (val > 0) {
                    onAddCash(val);
                    setAmount('');
                    onClose();
                } else {
                    alert("Please enter a valid amount.");
                }
            };

            return (
                <div class="fixed inset-0 bg-black/50 flex items-center justify-center p-4 z-[60]">
                    <div class="bg-white dark:bg-zinc-900 border border-black dark:border-white p-6 max-w-sm w-full shadow-2xl rounded-sm">
                        <h2 class="text-xl font-bold mb-4 uppercase">Add Cash</h2>
                        <form onSubmit={handleSubmit} class="space-y-4 font-mono text-sm">
                            <div class="space-y-2">
                                <label class="block font-bold">Amount (USD)</label>
                                <input
                                    type="number"
                                    min="1"
                                    step="0.01"
                                    value={amount}
                                    onChange={e => setAmount(e.target.value)}
                                    placeholder="e.g. 5000"
                                    class="w-full p-2 border border-black dark:border-white bg-transparent rounded-sm"
                                    autoFocus
                                />
                            </div>
                            <div class="flex gap-2 pt-2">
                                <button type="button" onClick={onClose} class="flex-1 py-2 border border-gray-300 dark:border-zinc-700 font-bold hover:bg-gray-100 dark:hover:bg-zinc-800">CANCEL</button>
                                <button type="submit" class="flex-1 py-2 bg-emerald-500 text-white font-bold hover:bg-emerald-600">ADD FUNDS</button>
                            </div>
                        </form>
                    </div>
                </div>
            );
        };

        const MainContent = ({ activeTab, marketData, loading, portfolio, liveEquity, onOpenTrade, selectedAsset, onSelectAsset, onOpenAddCash, config, updateConfig }) => {
            const currentAsset = selectedAsset || (marketData.us[0] || { symbol: 'AAPL', price: 173.50, change: 1.25, name: 'Apple Inc.' });

            if (activeTab === 'Dashboard') {
                return (
                    <section class="col-span-3 space-y-8">
                        <div class="grid grid-cols-2 gap-4">
                            <div class="bg-white dark:bg-zinc-800 border border-gray-200 dark:border-zinc-700 p-6 rounded-sm shadow-sm">
                                <span class="text-xs uppercase font-bold text-gray-400">Total Equity</span>
                                <div class="text-2xl font-bold font-mono">{formatCurrency(liveEquity !== undefined ? liveEquity : portfolio.equity)}</div>
                            </div>
                            <div class="bg-white dark:bg-zinc-800 border border-gray-200 dark:border-zinc-700 p-6 rounded-sm shadow-sm relative group">
                                <span class="text-xs uppercase font-bold text-gray-400">Available Cash</span>
                                <div class="text-2xl font-bold font-mono">{formatCurrency(portfolio.cash)}</div>
                                <button
                                    onClick={onOpenAddCash}
                                    class="absolute top-4 right-4 bg-emerald-100 dark:bg-emerald-900/30 text-emerald-600 dark:text-emerald-400 p-2 rounded-full hover:bg-emerald-200 dark:hover:bg-emerald-900/50 transition"
                                    title="Add Cash"
                                >
                                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"><line x1="12" y1="5" x2="12" y2="19"></line><line x1="5" y1="12" x2="19" y2="12"></line></svg>
                                </button>
                            </div>
                        </div>
                        <PositionsTable positions={portfolio.positions} marketData={marketData} onOpenTrade={onOpenTrade} />
                        <MarketTable title="Top Movers" data={marketData.us.slice(0, 3)} loading={loading} onOpenTrade={onOpenTrade} onSelect={onSelectAsset} />
                    </section>
                );
            }

            if (activeTab === 'History') {
                return (
                    <section class="col-span-3 space-y-8">
                        <HistoryTable history={portfolio.history} />
                    </section>
                );
            }

            if (activeTab === 'Settings') {
                return (
                    <section class="col-span-3 space-y-8">
                        <Settings marketData={marketData} config={config} updateConfig={updateConfig} />
                    </section>
                );
            }

            if (activeTab === 'Beginner Stats') {
                return (
                    <section class="col-span-3 space-y-8">
                        <BeginnerStats portfolio={portfolio} marketData={marketData} />
                    </section>
                );
            }

            let displayData = [];
            if (activeTab === 'US Markets') displayData = marketData.us;
            if (activeTab === 'Polish Stocks') displayData = marketData.pl;
            if (activeTab === 'Crypto') displayData = marketData.crypto;

            return (
                <section class="col-span-3 space-y-8">
                    {/* Dynamic Chart Area */}
                    <div class="bg-white dark:bg-zinc-800 border border-gray-200 dark:border-zinc-700 p-8 rounded-sm h-96 flex flex-col justify-between shadow-sm">
                        <div class="flex justify-between items-start mb-4">
                            <div>
                                <h2 class="text-2xl font-bold">{currentAsset.symbol}</h2>
                                <span class="font-mono text-gray-500">{currentAsset.name}</span>
                            </div>
                            <div class="text-right">
                                <div class="text-3xl font-mono font-bold">{formatCurrency(currentAsset.price)}</div>
                                <div class={`text-sm font-bold ${currentAsset.change >= 0 ? 'text-emerald-500' : 'text-red-500'}`}>{formatPct(currentAsset.change)}</div>
                            </div>
                        </div>
                        <div class="flex-1 relative w-full h-full">
                            <ChartComponent asset={currentAsset} />
                        </div>
                        <div class="flex gap-4 mt-4">
                            <button onClick={() => onOpenTrade(currentAsset)} class="flex-1 bg-black text-white dark:bg-white dark:text-black py-2 font-bold uppercase rounded-sm hover:opacity-80">Trade {currentAsset.symbol}</button>
                        </div>
                    </div>

                    <div class="bg-white dark:bg-zinc-800 border border-gray-200 dark:border-zinc-700 rounded-sm overflow-hidden shadow-sm">
                        <h2 class="text-2xl font-bold mb-2 px-4 pt-4">{activeTab}</h2>
                        <MarketTable title={`Live ${activeTab} Data`} data={displayData} loading={loading} onOpenTrade={onOpenTrade} onSelect={onSelectAsset} />
                    </div>
                </section>
            );
        };

        // --- Toast Notification Component ---
        const ToastContainer = ({ toasts }) => (
            <div class="fixed bottom-4 right-4 z-50 flex flex-col gap-2 pointer-events-none">
                {toasts.map(t => (
                    <div key={t.id} class={`p-4 rounded-sm shadow-lg border-l-4 text-sm font-bold pointer-events-auto animate-bounce ${t.type === 'error' ? 'bg-white border-red-500 text-red-600' : 'bg-white border-emerald-500 text-emerald-600'} dark:bg-zinc-800 dark:text-gray-100`}>
                        {t.message}
                    </div>
                ))}
            </div>
        );

        const App = () => {
            const [darkMode, setDarkMode] = useState(() => localStorage.getItem('theme') === 'dark');
            const [activeTab, setActiveTab] = useState('Dashboard');
            const [loading, setLoading] = useState(true);
            const [marketData, setMarketData] = useState({ us: [], pl: [], crypto: [] });
            const [portfolio, setPortfolio] = useState({ cash: 100000, positions: [], history: [], equity: 100000 });
            const [portfolioLoaded, setPortfolioLoaded] = useState(false);
            const [appVersion, setAppVersion] = useState('');

            useEffect(() => {
                fetch('/api/version')
                    .then(res => res.json())
                    .then(data => setAppVersion(data.version))
                    .catch(err => console.error("Failed to load version", err));
            }, []);

            // Fetch Portfolio on mount & Poll every 5s
            useEffect(() => {
                const fetchPortfolioData = () => {
                    fetch('/api/portfolio')
                        .then(res => res.json())
                        .then(data => {
                            if (data && data.cash !== undefined) {
                                // Only update state if data has actually changed to avoid re-renders
                                // Simplify by always setting, React handles some shallow comparison, but deep compare would be better.
                                // Let's just update for now.
                                setPortfolio(prev => {
                                    // Basic stringify compare to prevent infinite loop of savePortfolio -> fetch -> save -> fetch
                                    const newDataStr = JSON.stringify(data);
                                    const prevDataStr = JSON.stringify(prev);

                                    if (newDataStr !== prevDataStr) {
                                        return {
                                            ...data,
                                            history: data.history || [],
                                            positions: data.positions || []
                                        };
                                    }
                                    return prev;
                                });
                            }
                            setPortfolioLoaded(true);
                        })
                        .catch(err => {
                            console.error('Failed to load portfolio:', err);
                            setPortfolioLoaded(true);
                        });
                };

                fetchPortfolioData(); // Initial load
                const intervalId = setInterval(fetchPortfolioData, 5000); // Poll every 5s
                return () => clearInterval(intervalId);
            }, []);
            const [tradeAsset, setTradeAsset] = useState(null);
            const [selectedAsset, setSelectedAsset] = useState(null);
            const [isAddCashOpen, setIsAddCashOpen] = useState(false);

            // Auto-Trading State
            const [autoTradeEnabled, setAutoTradeEnabled] = useState(false);
            const [config, setConfig] = useState({
                interval: 60,
                posSizePct: 10,
                slPct: 3,
                tpPct: 5
            });
            const [nextTradeTime, setNextTradeTime] = useState(null);

            useEffect(() => {
                fetch('/api/bot/config')
                    .then(res => res.json())
                    .then(data => {
                        setAutoTradeEnabled(data.enabled);
                        setConfig(data);
                    })
                    .catch(err => console.error("Failed to load bot config:", err));
            }, []);
            const [toasts, setToasts] = useState([]);

            const addToast = (message, type = 'info') => {
                const id = Date.now() + Math.random();
                setToasts(prev => [...prev, { id, message, type }]);
                setTimeout(() => setToasts(prev => prev.filter(t => t.id !== id)), 5000);
            };

            // Countdown Timer
            const [timeLeft, setTimeLeft] = useState(0);

            useEffect(() => {
                if (!autoTradeEnabled || !nextTradeTime) {
                    setTimeLeft(0);
                    return;
                }
                const timer = setInterval(() => {
                    const diff = Math.max(0, Math.ceil((nextTradeTime - Date.now()) / 1000));
                    setTimeLeft(diff);
                }, 1000);
                return () => clearInterval(timer);
            }, [autoTradeEnabled, nextTradeTime]);

            const handleAddCash = (amount) => {
                setPortfolio(prev => {
                    const newCash = prev.cash + amount;
                    const newEquity = prev.equity + amount;
                    const newHistory = [...prev.history, {
                        date: new Date(),
                        type: 'DEPOSIT',
                        symbol: 'USD',
                        qty: amount,
                        price: 1,
                        reason: 'Deposit Funds'
                    }];
                    const newPortfolio = {
                        ...prev,
                        cash: newCash,
                        equity: newEquity,
                        history: newHistory
                    };

                    fetch('/api/portfolio', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(newPortfolio)
                    }).catch(err => console.error("Failed to save portfolio after deposit:", err));

                    return newPortfolio;
                });
                addToast(`Successfully added ${formatCurrency(amount)}`, 'success');
            };

            // Trade Execution Logic (Manual via UI)
            const handleManualTrade = async (asset, mode, qty) => {
                setTradeAsset(null); // Close modal
                try {
                    const res = await fetch('/api/trade', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ symbol: asset.symbol, type: mode, qty, price: asset.price })
                    });
                    const data = await res.json();
                    if (data.error) {
                        addToast(data.error, 'error');
                        return;
                    }
                    setPortfolio(data.portfolio);
                    addToast(`Manual ${mode}: ${asset.symbol}`, mode === 'BUY' ? 'success' : 'info');
                } catch (e) {
                    addToast("Trade failed", 'error');
                }
            };

            // AUTO TRADING API LOGIC
            const toggleBot = () => {
                fetch('/api/bot/toggle', { method: 'POST' })
                    .then(res => {
                        if (!res.ok) throw new Error(`HTTP ${res.status}: Server returned an error.`);
                        return res.json();
                    })
                    .then(data => {
                        setAutoTradeEnabled(data.enabled);
                        setConfig(data);
                        addToast(data.enabled ? 'Robot Started' : 'Robot Stopped', data.enabled ? 'success' : 'info');
                    })
                    .catch(e => {
                        console.error("Toggle error:", e);
                        addToast("Failed to toggle robot. Is the server running?", "error");
                    });
            };

            const updateConfig = (newConfig) => {
                setConfig(newConfig);
                fetch('/api/bot/config', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(newConfig)
                })
                    .then(res => {
                        if (!res.ok) throw new Error("Server error");
                        return res.json();
                    })
                    .catch(e => {
                        console.error("Config update error:", e);
                        addToast("Failed to save config.", "error");
                    });
            };

            // Local Timer for UI feedback only
            useEffect(() => {
                if (!autoTradeEnabled || loading) {
                    setNextTradeTime(null);
                    return;
                }
                setNextTradeTime(Date.now() + config.interval * 1000);
                const intervalId = setInterval(() => {
                    setNextTradeTime(Date.now() + config.interval * 1000);
                }, config.interval * 1000);

                return () => clearInterval(intervalId);
            }, [autoTradeEnabled, loading, config.interval]);

            // Calculate live equity
            const liveEquity = useMemo(() => {
                let positionValue = 0;
                const allAssets = marketData ? [...(marketData.us || []), ...(marketData.pl || []), ...(marketData.crypto || [])] : [];

                (portfolio.positions || []).forEach(p => {
                    const asset = allAssets.find(a => a.symbol === p.symbol);
                    const currentPrice = asset ? asset.price : p.avgPrice;
                    positionValue += p.qty * currentPrice;
                });

                return portfolio.cash + positionValue;
            }, [portfolio.positions, portfolio.cash, marketData]);


            // Theme Toggle
            useEffect(() => {
                if (darkMode) {
                    document.documentElement.classList.add('dark');
                    localStorage.setItem('theme', 'dark');
                } else {
                    document.documentElement.classList.remove('dark');
                    localStorage.setItem('theme', 'light');
                }
            }, [darkMode]);

            useEffect(() => {
                const loadData = async () => {
                    try {
                        const res = await fetch('/api/market-data');
                        const data = await res.json();
                        if (data && data.us) {
                            setMarketData(data);
                            setLoading(false);
                        }
                    } catch (err) {
                        console.error("Critical error loading market data:", err);
                        setLoading(false);
                    }
                };

                loadData(); // Initial load
                const intervalId = setInterval(loadData, 5000); // Poll server every 5s
                return () => clearInterval(intervalId);
            }, []);

            return (
                <div class="font-sans text-gray-900 dark:text-gray-100 min-h-screen bg-gray-100 dark:bg-zinc-900 transition-colors duration-300">
                    <ToastContainer toasts={toasts} />

                    {tradeAsset && (
                        <TradeModal
                            isOpen={!!tradeAsset}
                            asset={tradeAsset}
                            onClose={() => setTradeAsset(null)}
                            onTrade={handleManualTrade}
                        />
                    )}
                    <AddCashModal isOpen={isAddCashOpen} onClose={() => setIsAddCashOpen(false)} onAddCash={handleAddCash} />

                    <div class="container mx-auto p-4 max-w-7xl">
                        <div class="fixed top-4 right-4 z-40 flex items-center gap-2">
                            {autoTradeEnabled && (
                                <div class="bg-black text-white px-3 py-2 rounded-sm font-mono text-sm border border-white font-bold">
                                    Next: {timeLeft}s
                                </div>
                            )}
                            <button
                                onClick={toggleBot}
                                class={`px-4 py-2 font-bold rounded-sm border-2 ${autoTradeEnabled ? 'bg-emerald-500 text-white border-emerald-500 animate-pulse' : 'bg-gray-200 text-gray-500 border-gray-300'}`}
                            >
                                {autoTradeEnabled ? 'STOP ROBOT' : 'START ROBOT'}
                            </button>
                        </div>



                        <Header darkMode={darkMode} toggleTheme={() => setDarkMode(!darkMode)} portfolio={portfolio} liveEquity={liveEquity} appVersion={appVersion} />

                        <div class="grid grid-cols-1 md:grid-cols-4 gap-8">
                            <Sidebar activeTab={activeTab} setActiveTab={setActiveTab} />

                            <MainContent
                                activeTab={activeTab}
                                marketData={marketData}
                                loading={loading}
                                portfolio={portfolio}
                                liveEquity={liveEquity}
                                onOpenTrade={setTradeAsset}
                                selectedAsset={selectedAsset}
                                onSelectAsset={setSelectedAsset}
                                onOpenAddCash={() => setIsAddCashOpen(true)}
                                config={config}
                                updateConfig={updateConfig}

                            />
                        </div>
                    </div>
                </div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>

</html>